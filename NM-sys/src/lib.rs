// This file was generated by gir (https://github.com/gtk-rs/gir @ c530bb9)
// from gir-files (https://github.com/gtk-rs/gir-files @ ???)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]

extern crate libc;
extern crate glib_sys as glib;
extern crate gobject_sys as gobject;
extern crate gio_sys as gio;

#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, time_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type NM80211Mode = c_int;
pub const NM_802_11_MODE_UNKNOWN: NM80211Mode = 0;
pub const NM_802_11_MODE_ADHOC: NM80211Mode = 1;
pub const NM_802_11_MODE_INFRA: NM80211Mode = 2;
pub const NM_802_11_MODE_AP: NM80211Mode = 3;

pub type NMActiveConnectionState = c_int;
pub const NM_ACTIVE_CONNECTION_STATE_UNKNOWN: NMActiveConnectionState = 0;
pub const NM_ACTIVE_CONNECTION_STATE_ACTIVATING: NMActiveConnectionState = 1;
pub const NM_ACTIVE_CONNECTION_STATE_ACTIVATED: NMActiveConnectionState = 2;
pub const NM_ACTIVE_CONNECTION_STATE_DEACTIVATING: NMActiveConnectionState = 3;
pub const NM_ACTIVE_CONNECTION_STATE_DEACTIVATED: NMActiveConnectionState = 4;

pub type NMActiveConnectionStateReason = c_int;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_UNKNOWN: NMActiveConnectionStateReason = 0;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_NONE: NMActiveConnectionStateReason = 1;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_USER_DISCONNECTED: NMActiveConnectionStateReason = 2;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED: NMActiveConnectionStateReason = 3;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_STOPPED: NMActiveConnectionStateReason = 4;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_IP_CONFIG_INVALID: NMActiveConnectionStateReason = 5;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_CONNECT_TIMEOUT: NMActiveConnectionStateReason = 6;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT: NMActiveConnectionStateReason = 7;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_SERVICE_START_FAILED: NMActiveConnectionStateReason = 8;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_NO_SECRETS: NMActiveConnectionStateReason = 9;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_LOGIN_FAILED: NMActiveConnectionStateReason = 10;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_CONNECTION_REMOVED: NMActiveConnectionStateReason = 11;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_DEPENDENCY_FAILED: NMActiveConnectionStateReason = 12;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REALIZE_FAILED: NMActiveConnectionStateReason = 13;
pub const NM_ACTIVE_CONNECTION_STATE_REASON_DEVICE_REMOVED: NMActiveConnectionStateReason = 14;

pub type NMAgentManagerError = c_int;
pub const NM_AGENT_MANAGER_ERROR_FAILED: NMAgentManagerError = 0;
pub const NM_AGENT_MANAGER_ERROR_PERMISSION_DENIED: NMAgentManagerError = 1;
pub const NM_AGENT_MANAGER_ERROR_INVALID_IDENTIFIER: NMAgentManagerError = 2;
pub const NM_AGENT_MANAGER_ERROR_NOT_REGISTERED: NMAgentManagerError = 3;
pub const NM_AGENT_MANAGER_ERROR_NO_SECRETS: NMAgentManagerError = 4;
pub const NM_AGENT_MANAGER_ERROR_USER_CANCELED: NMAgentManagerError = 5;

pub type Capability = c_int;
pub const NM_CAPABILITY_TEAM: Capability = 1;
pub type NMCapability = Capability;

pub type NMCheckpointCreateFlags = c_int;
pub const NM_CHECKPOINT_CREATE_FLAG_NONE: NMCheckpointCreateFlags = 0;
pub const NM_CHECKPOINT_CREATE_FLAG_DESTROY_ALL: NMCheckpointCreateFlags = 1;
pub const NM_CHECKPOINT_CREATE_FLAG_DELETE_NEW_CONNECTIONS: NMCheckpointCreateFlags = 2;
pub const NM_CHECKPOINT_CREATE_FLAG_DISCONNECT_NEW_DEVICES: NMCheckpointCreateFlags = 4;

pub type NMClientError = c_int;
pub const NM_CLIENT_ERROR_FAILED: NMClientError = 0;
pub const NM_CLIENT_ERROR_MANAGER_NOT_RUNNING: NMClientError = 1;
pub const NM_CLIENT_ERROR_OBJECT_CREATION_FAILED: NMClientError = 2;

pub type NMClientPermission = c_int;
pub const NM_CLIENT_PERMISSION_NONE: NMClientPermission = 0;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_NETWORK: NMClientPermission = 1;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIFI: NMClientPermission = 2;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_WWAN: NMClientPermission = 3;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX: NMClientPermission = 4;
pub const NM_CLIENT_PERMISSION_SLEEP_WAKE: NMClientPermission = 5;
pub const NM_CLIENT_PERMISSION_NETWORK_CONTROL: NMClientPermission = 6;
pub const NM_CLIENT_PERMISSION_WIFI_SHARE_PROTECTED: NMClientPermission = 7;
pub const NM_CLIENT_PERMISSION_WIFI_SHARE_OPEN: NMClientPermission = 8;
pub const NM_CLIENT_PERMISSION_SETTINGS_MODIFY_SYSTEM: NMClientPermission = 9;
pub const NM_CLIENT_PERMISSION_SETTINGS_MODIFY_OWN: NMClientPermission = 10;
pub const NM_CLIENT_PERMISSION_SETTINGS_MODIFY_HOSTNAME: NMClientPermission = 11;
pub const NM_CLIENT_PERMISSION_SETTINGS_MODIFY_GLOBAL_DNS: NMClientPermission = 12;
pub const NM_CLIENT_PERMISSION_RELOAD: NMClientPermission = 13;
pub const NM_CLIENT_PERMISSION_CHECKPOINT_ROLLBACK: NMClientPermission = 14;
pub const NM_CLIENT_PERMISSION_ENABLE_DISABLE_STATISTICS: NMClientPermission = 15;

pub type NMClientPermissionResult = c_int;
pub const NM_CLIENT_PERMISSION_RESULT_UNKNOWN: NMClientPermissionResult = 0;
pub const NM_CLIENT_PERMISSION_RESULT_YES: NMClientPermissionResult = 1;
pub const NM_CLIENT_PERMISSION_RESULT_AUTH: NMClientPermissionResult = 2;
pub const NM_CLIENT_PERMISSION_RESULT_NO: NMClientPermissionResult = 3;

pub type NMConnectionError = c_int;
pub const NM_CONNECTION_ERROR_FAILED: NMConnectionError = 0;
pub const NM_CONNECTION_ERROR_SETTING_NOT_FOUND: NMConnectionError = 1;
pub const NM_CONNECTION_ERROR_PROPERTY_NOT_FOUND: NMConnectionError = 2;
pub const NM_CONNECTION_ERROR_PROPERTY_NOT_SECRET: NMConnectionError = 3;
pub const NM_CONNECTION_ERROR_MISSING_SETTING: NMConnectionError = 4;
pub const NM_CONNECTION_ERROR_INVALID_SETTING: NMConnectionError = 5;
pub const NM_CONNECTION_ERROR_MISSING_PROPERTY: NMConnectionError = 6;
pub const NM_CONNECTION_ERROR_INVALID_PROPERTY: NMConnectionError = 7;

pub type NMConnectivityState = c_int;
pub const NM_CONNECTIVITY_UNKNOWN: NMConnectivityState = 0;
pub const NM_CONNECTIVITY_NONE: NMConnectivityState = 1;
pub const NM_CONNECTIVITY_PORTAL: NMConnectivityState = 2;
pub const NM_CONNECTIVITY_LIMITED: NMConnectivityState = 3;
pub const NM_CONNECTIVITY_FULL: NMConnectivityState = 4;

pub type NMCryptoError = c_int;
pub const NM_CRYPTO_ERROR_FAILED: NMCryptoError = 0;
pub const NM_CRYPTO_ERROR_INVALID_DATA: NMCryptoError = 1;
pub const NM_CRYPTO_ERROR_INVALID_PASSWORD: NMCryptoError = 2;
pub const NM_CRYPTO_ERROR_UNKNOWN_CIPHER: NMCryptoError = 3;
pub const NM_CRYPTO_ERROR_DECRYPTION_FAILED: NMCryptoError = 4;
pub const NM_CRYPTO_ERROR_ENCRYPTION_FAILED: NMCryptoError = 5;

pub type NMDeviceError = c_int;
pub const NM_DEVICE_ERROR_FAILED: NMDeviceError = 0;
pub const NM_DEVICE_ERROR_CREATION_FAILED: NMDeviceError = 1;
pub const NM_DEVICE_ERROR_INVALID_CONNECTION: NMDeviceError = 2;
pub const NM_DEVICE_ERROR_INCOMPATIBLE_CONNECTION: NMDeviceError = 3;
pub const NM_DEVICE_ERROR_NOT_ACTIVE: NMDeviceError = 4;
pub const NM_DEVICE_ERROR_NOT_SOFTWARE: NMDeviceError = 5;
pub const NM_DEVICE_ERROR_NOT_ALLOWED: NMDeviceError = 6;
pub const NM_DEVICE_ERROR_SPECIFIC_OBJECT_NOT_FOUND: NMDeviceError = 7;
pub const NM_DEVICE_ERROR_VERSION_ID_MISMATCH: NMDeviceError = 8;

pub type NMDeviceState = c_int;
pub const NM_DEVICE_STATE_UNKNOWN: NMDeviceState = 0;
pub const NM_DEVICE_STATE_UNMANAGED: NMDeviceState = 10;
pub const NM_DEVICE_STATE_UNAVAILABLE: NMDeviceState = 20;
pub const NM_DEVICE_STATE_DISCONNECTED: NMDeviceState = 30;
pub const NM_DEVICE_STATE_PREPARE: NMDeviceState = 40;
pub const NM_DEVICE_STATE_CONFIG: NMDeviceState = 50;
pub const NM_DEVICE_STATE_NEED_AUTH: NMDeviceState = 60;
pub const NM_DEVICE_STATE_IP_CONFIG: NMDeviceState = 70;
pub const NM_DEVICE_STATE_IP_CHECK: NMDeviceState = 80;
pub const NM_DEVICE_STATE_SECONDARIES: NMDeviceState = 90;
pub const NM_DEVICE_STATE_ACTIVATED: NMDeviceState = 100;
pub const NM_DEVICE_STATE_DEACTIVATING: NMDeviceState = 110;
pub const NM_DEVICE_STATE_FAILED: NMDeviceState = 120;

pub type NMDeviceStateReason = c_int;
pub const NM_DEVICE_STATE_REASON_NONE: NMDeviceStateReason = 0;
pub const NM_DEVICE_STATE_REASON_UNKNOWN: NMDeviceStateReason = 1;
pub const NM_DEVICE_STATE_REASON_NOW_MANAGED: NMDeviceStateReason = 2;
pub const NM_DEVICE_STATE_REASON_NOW_UNMANAGED: NMDeviceStateReason = 3;
pub const NM_DEVICE_STATE_REASON_CONFIG_FAILED: NMDeviceStateReason = 4;
pub const NM_DEVICE_STATE_REASON_IP_CONFIG_UNAVAILABLE: NMDeviceStateReason = 5;
pub const NM_DEVICE_STATE_REASON_IP_CONFIG_EXPIRED: NMDeviceStateReason = 6;
pub const NM_DEVICE_STATE_REASON_NO_SECRETS: NMDeviceStateReason = 7;
pub const NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT: NMDeviceStateReason = 8;
pub const NM_DEVICE_STATE_REASON_SUPPLICANT_CONFIG_FAILED: NMDeviceStateReason = 9;
pub const NM_DEVICE_STATE_REASON_SUPPLICANT_FAILED: NMDeviceStateReason = 10;
pub const NM_DEVICE_STATE_REASON_SUPPLICANT_TIMEOUT: NMDeviceStateReason = 11;
pub const NM_DEVICE_STATE_REASON_PPP_START_FAILED: NMDeviceStateReason = 12;
pub const NM_DEVICE_STATE_REASON_PPP_DISCONNECT: NMDeviceStateReason = 13;
pub const NM_DEVICE_STATE_REASON_PPP_FAILED: NMDeviceStateReason = 14;
pub const NM_DEVICE_STATE_REASON_DHCP_START_FAILED: NMDeviceStateReason = 15;
pub const NM_DEVICE_STATE_REASON_DHCP_ERROR: NMDeviceStateReason = 16;
pub const NM_DEVICE_STATE_REASON_DHCP_FAILED: NMDeviceStateReason = 17;
pub const NM_DEVICE_STATE_REASON_SHARED_START_FAILED: NMDeviceStateReason = 18;
pub const NM_DEVICE_STATE_REASON_SHARED_FAILED: NMDeviceStateReason = 19;
pub const NM_DEVICE_STATE_REASON_AUTOIP_START_FAILED: NMDeviceStateReason = 20;
pub const NM_DEVICE_STATE_REASON_AUTOIP_ERROR: NMDeviceStateReason = 21;
pub const NM_DEVICE_STATE_REASON_AUTOIP_FAILED: NMDeviceStateReason = 22;
pub const NM_DEVICE_STATE_REASON_MODEM_BUSY: NMDeviceStateReason = 23;
pub const NM_DEVICE_STATE_REASON_MODEM_NO_DIAL_TONE: NMDeviceStateReason = 24;
pub const NM_DEVICE_STATE_REASON_MODEM_NO_CARRIER: NMDeviceStateReason = 25;
pub const NM_DEVICE_STATE_REASON_MODEM_DIAL_TIMEOUT: NMDeviceStateReason = 26;
pub const NM_DEVICE_STATE_REASON_MODEM_DIAL_FAILED: NMDeviceStateReason = 27;
pub const NM_DEVICE_STATE_REASON_MODEM_INIT_FAILED: NMDeviceStateReason = 28;
pub const NM_DEVICE_STATE_REASON_GSM_APN_FAILED: NMDeviceStateReason = 29;
pub const NM_DEVICE_STATE_REASON_GSM_REGISTRATION_NOT_SEARCHING: NMDeviceStateReason = 30;
pub const NM_DEVICE_STATE_REASON_GSM_REGISTRATION_DENIED: NMDeviceStateReason = 31;
pub const NM_DEVICE_STATE_REASON_GSM_REGISTRATION_TIMEOUT: NMDeviceStateReason = 32;
pub const NM_DEVICE_STATE_REASON_GSM_REGISTRATION_FAILED: NMDeviceStateReason = 33;
pub const NM_DEVICE_STATE_REASON_GSM_PIN_CHECK_FAILED: NMDeviceStateReason = 34;
pub const NM_DEVICE_STATE_REASON_FIRMWARE_MISSING: NMDeviceStateReason = 35;
pub const NM_DEVICE_STATE_REASON_REMOVED: NMDeviceStateReason = 36;
pub const NM_DEVICE_STATE_REASON_SLEEPING: NMDeviceStateReason = 37;
pub const NM_DEVICE_STATE_REASON_CONNECTION_REMOVED: NMDeviceStateReason = 38;
pub const NM_DEVICE_STATE_REASON_USER_REQUESTED: NMDeviceStateReason = 39;
pub const NM_DEVICE_STATE_REASON_CARRIER: NMDeviceStateReason = 40;
pub const NM_DEVICE_STATE_REASON_CONNECTION_ASSUMED: NMDeviceStateReason = 41;
pub const NM_DEVICE_STATE_REASON_SUPPLICANT_AVAILABLE: NMDeviceStateReason = 42;
pub const NM_DEVICE_STATE_REASON_MODEM_NOT_FOUND: NMDeviceStateReason = 43;
pub const NM_DEVICE_STATE_REASON_BT_FAILED: NMDeviceStateReason = 44;
pub const NM_DEVICE_STATE_REASON_GSM_SIM_NOT_INSERTED: NMDeviceStateReason = 45;
pub const NM_DEVICE_STATE_REASON_GSM_SIM_PIN_REQUIRED: NMDeviceStateReason = 46;
pub const NM_DEVICE_STATE_REASON_GSM_SIM_PUK_REQUIRED: NMDeviceStateReason = 47;
pub const NM_DEVICE_STATE_REASON_GSM_SIM_WRONG: NMDeviceStateReason = 48;
pub const NM_DEVICE_STATE_REASON_INFINIBAND_MODE: NMDeviceStateReason = 49;
pub const NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED: NMDeviceStateReason = 50;
pub const NM_DEVICE_STATE_REASON_BR2684_FAILED: NMDeviceStateReason = 51;
pub const NM_DEVICE_STATE_REASON_MODEM_MANAGER_UNAVAILABLE: NMDeviceStateReason = 52;
pub const NM_DEVICE_STATE_REASON_SSID_NOT_FOUND: NMDeviceStateReason = 53;
pub const NM_DEVICE_STATE_REASON_SECONDARY_CONNECTION_FAILED: NMDeviceStateReason = 54;
pub const NM_DEVICE_STATE_REASON_DCB_FCOE_FAILED: NMDeviceStateReason = 55;
pub const NM_DEVICE_STATE_REASON_TEAMD_CONTROL_FAILED: NMDeviceStateReason = 56;
pub const NM_DEVICE_STATE_REASON_MODEM_FAILED: NMDeviceStateReason = 57;
pub const NM_DEVICE_STATE_REASON_MODEM_AVAILABLE: NMDeviceStateReason = 58;
pub const NM_DEVICE_STATE_REASON_SIM_PIN_INCORRECT: NMDeviceStateReason = 59;
pub const NM_DEVICE_STATE_REASON_NEW_ACTIVATION: NMDeviceStateReason = 60;
pub const NM_DEVICE_STATE_REASON_PARENT_CHANGED: NMDeviceStateReason = 61;
pub const NM_DEVICE_STATE_REASON_PARENT_MANAGED_CHANGED: NMDeviceStateReason = 62;

pub type NMDeviceType = c_int;
pub const NM_DEVICE_TYPE_UNKNOWN: NMDeviceType = 0;
pub const NM_DEVICE_TYPE_ETHERNET: NMDeviceType = 1;
pub const NM_DEVICE_TYPE_WIFI: NMDeviceType = 2;
pub const NM_DEVICE_TYPE_UNUSED1: NMDeviceType = 3;
pub const NM_DEVICE_TYPE_UNUSED2: NMDeviceType = 4;
pub const NM_DEVICE_TYPE_BT: NMDeviceType = 5;
pub const NM_DEVICE_TYPE_OLPC_MESH: NMDeviceType = 6;
pub const NM_DEVICE_TYPE_WIMAX: NMDeviceType = 7;
pub const NM_DEVICE_TYPE_MODEM: NMDeviceType = 8;
pub const NM_DEVICE_TYPE_INFINIBAND: NMDeviceType = 9;
pub const NM_DEVICE_TYPE_BOND: NMDeviceType = 10;
pub const NM_DEVICE_TYPE_VLAN: NMDeviceType = 11;
pub const NM_DEVICE_TYPE_ADSL: NMDeviceType = 12;
pub const NM_DEVICE_TYPE_BRIDGE: NMDeviceType = 13;
pub const NM_DEVICE_TYPE_GENERIC: NMDeviceType = 14;
pub const NM_DEVICE_TYPE_TEAM: NMDeviceType = 15;
pub const NM_DEVICE_TYPE_TUN: NMDeviceType = 16;
pub const NM_DEVICE_TYPE_IP_TUNNEL: NMDeviceType = 17;
pub const NM_DEVICE_TYPE_MACVLAN: NMDeviceType = 18;
pub const NM_DEVICE_TYPE_VXLAN: NMDeviceType = 19;
pub const NM_DEVICE_TYPE_VETH: NMDeviceType = 20;
pub const NM_DEVICE_TYPE_MACSEC: NMDeviceType = 21;
pub const NM_DEVICE_TYPE_DUMMY: NMDeviceType = 22;

pub type NMIPTunnelMode = c_int;
pub const NM_IP_TUNNEL_MODE_UNKNOWN: NMIPTunnelMode = 0;
pub const NM_IP_TUNNEL_MODE_IPIP: NMIPTunnelMode = 1;
pub const NM_IP_TUNNEL_MODE_GRE: NMIPTunnelMode = 2;
pub const NM_IP_TUNNEL_MODE_SIT: NMIPTunnelMode = 3;
pub const NM_IP_TUNNEL_MODE_ISATAP: NMIPTunnelMode = 4;
pub const NM_IP_TUNNEL_MODE_VTI: NMIPTunnelMode = 5;
pub const NM_IP_TUNNEL_MODE_IP6IP6: NMIPTunnelMode = 6;
pub const NM_IP_TUNNEL_MODE_IPIP6: NMIPTunnelMode = 7;
pub const NM_IP_TUNNEL_MODE_IP6GRE: NMIPTunnelMode = 8;
pub const NM_IP_TUNNEL_MODE_VTI6: NMIPTunnelMode = 9;

pub type NMManagerError = c_int;
pub const NM_MANAGER_ERROR_FAILED: NMManagerError = 0;
pub const NM_MANAGER_ERROR_PERMISSION_DENIED: NMManagerError = 1;
pub const NM_MANAGER_ERROR_UNKNOWN_CONNECTION: NMManagerError = 2;
pub const NM_MANAGER_ERROR_UNKNOWN_DEVICE: NMManagerError = 3;
pub const NM_MANAGER_ERROR_CONNECTION_NOT_AVAILABLE: NMManagerError = 4;
pub const NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE: NMManagerError = 5;
pub const NM_MANAGER_ERROR_CONNECTION_ALREADY_ACTIVE: NMManagerError = 6;
pub const NM_MANAGER_ERROR_DEPENDENCY_FAILED: NMManagerError = 7;
pub const NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE: NMManagerError = 8;
pub const NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED: NMManagerError = 9;
pub const NM_MANAGER_ERROR_UNKNOWN_LOG_LEVEL: NMManagerError = 10;
pub const NM_MANAGER_ERROR_UNKNOWN_LOG_DOMAIN: NMManagerError = 11;
pub const NM_MANAGER_ERROR_INVALID_ARGUMENTS: NMManagerError = 12;
pub const NM_MANAGER_ERROR_MISSING_PLUGIN: NMManagerError = 13;

pub type NMMetered = c_int;
pub const NM_METERED_UNKNOWN: NMMetered = 0;
pub const NM_METERED_YES: NMMetered = 1;
pub const NM_METERED_NO: NMMetered = 2;
pub const NM_METERED_GUESS_YES: NMMetered = 3;
pub const NM_METERED_GUESS_NO: NMMetered = 4;

pub type NMRollbackResult = c_int;
pub const NM_ROLLBACK_RESULT_OK: NMRollbackResult = 0;
pub const NM_ROLLBACK_RESULT_ERR_NO_DEVICE: NMRollbackResult = 1;
pub const NM_ROLLBACK_RESULT_ERR_DEVICE_UNMANAGED: NMRollbackResult = 2;
pub const NM_ROLLBACK_RESULT_ERR_FAILED: NMRollbackResult = 3;

pub type NMSecretAgentError = c_int;
pub const NM_SECRET_AGENT_ERROR_FAILED: NMSecretAgentError = 0;
pub const NM_SECRET_AGENT_ERROR_PERMISSION_DENIED: NMSecretAgentError = 1;
pub const NM_SECRET_AGENT_ERROR_INVALID_CONNECTION: NMSecretAgentError = 2;
pub const NM_SECRET_AGENT_ERROR_USER_CANCELED: NMSecretAgentError = 3;
pub const NM_SECRET_AGENT_ERROR_AGENT_CANCELED: NMSecretAgentError = 4;
pub const NM_SECRET_AGENT_ERROR_NO_SECRETS: NMSecretAgentError = 5;

pub type NMSetting8021xCKFormat = c_int;
pub const NM_SETTING_802_1X_CK_FORMAT_UNKNOWN: NMSetting8021xCKFormat = 0;
pub const NM_SETTING_802_1X_CK_FORMAT_X509: NMSetting8021xCKFormat = 1;
pub const NM_SETTING_802_1X_CK_FORMAT_RAW_KEY: NMSetting8021xCKFormat = 2;
pub const NM_SETTING_802_1X_CK_FORMAT_PKCS12: NMSetting8021xCKFormat = 3;

pub type NMSetting8021xCKScheme = c_int;
pub const NM_SETTING_802_1X_CK_SCHEME_UNKNOWN: NMSetting8021xCKScheme = 0;
pub const NM_SETTING_802_1X_CK_SCHEME_BLOB: NMSetting8021xCKScheme = 1;
pub const NM_SETTING_802_1X_CK_SCHEME_PATH: NMSetting8021xCKScheme = 2;
pub const NM_SETTING_802_1X_CK_SCHEME_PKCS11: NMSetting8021xCKScheme = 3;

pub type NMSettingCompareFlags = c_int;
pub const NM_SETTING_COMPARE_FLAG_EXACT: NMSettingCompareFlags = 0;
pub const NM_SETTING_COMPARE_FLAG_FUZZY: NMSettingCompareFlags = 1;
pub const NM_SETTING_COMPARE_FLAG_IGNORE_ID: NMSettingCompareFlags = 2;
pub const NM_SETTING_COMPARE_FLAG_IGNORE_SECRETS: NMSettingCompareFlags = 4;
pub const NM_SETTING_COMPARE_FLAG_IGNORE_AGENT_OWNED_SECRETS: NMSettingCompareFlags = 8;
pub const NM_SETTING_COMPARE_FLAG_IGNORE_NOT_SAVED_SECRETS: NMSettingCompareFlags = 16;
pub const NM_SETTING_COMPARE_FLAG_DIFF_RESULT_WITH_DEFAULT: NMSettingCompareFlags = 32;
pub const NM_SETTING_COMPARE_FLAG_DIFF_RESULT_NO_DEFAULT: NMSettingCompareFlags = 64;
pub const NM_SETTING_COMPARE_FLAG_IGNORE_TIMESTAMP: NMSettingCompareFlags = 128;

pub type NMSettingConnectionAutoconnectSlaves = c_int;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_DEFAULT: NMSettingConnectionAutoconnectSlaves = -1;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_NO: NMSettingConnectionAutoconnectSlaves = 0;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES_YES: NMSettingConnectionAutoconnectSlaves = 1;

pub type NMSettingConnectionLldp = c_int;
pub const NM_SETTING_CONNECTION_LLDP_DEFAULT: NMSettingConnectionLldp = -1;
pub const NM_SETTING_CONNECTION_LLDP_DISABLE: NMSettingConnectionLldp = 0;
pub const NM_SETTING_CONNECTION_LLDP_ENABLE_RX: NMSettingConnectionLldp = 1;

pub type NMSettingDiffResult = c_int;
pub const NM_SETTING_DIFF_RESULT_UNKNOWN: NMSettingDiffResult = 0;
pub const NM_SETTING_DIFF_RESULT_IN_A: NMSettingDiffResult = 1;
pub const NM_SETTING_DIFF_RESULT_IN_B: NMSettingDiffResult = 2;
pub const NM_SETTING_DIFF_RESULT_IN_A_DEFAULT: NMSettingDiffResult = 4;

pub type NMSettingIP6ConfigAddrGenMode = c_int;
pub const NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_EUI64: NMSettingIP6ConfigAddrGenMode = 0;
pub const NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE_STABLE_PRIVACY: NMSettingIP6ConfigAddrGenMode = 1;

pub type NMSettingIP6ConfigPrivacy = c_int;
pub const NM_SETTING_IP6_CONFIG_PRIVACY_UNKNOWN: NMSettingIP6ConfigPrivacy = -1;
pub const NM_SETTING_IP6_CONFIG_PRIVACY_DISABLED: NMSettingIP6ConfigPrivacy = 0;
pub const NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_PUBLIC_ADDR: NMSettingIP6ConfigPrivacy = 1;
pub const NM_SETTING_IP6_CONFIG_PRIVACY_PREFER_TEMP_ADDR: NMSettingIP6ConfigPrivacy = 2;

pub type NMSettingMacRandomization = c_int;
pub const NM_SETTING_MAC_RANDOMIZATION_DEFAULT: NMSettingMacRandomization = 0;
pub const NM_SETTING_MAC_RANDOMIZATION_NEVER: NMSettingMacRandomization = 1;
pub const NM_SETTING_MAC_RANDOMIZATION_ALWAYS: NMSettingMacRandomization = 2;

pub type NMSettingMacsecMode = c_int;
pub const NM_SETTING_MACSEC_MODE_PSK: NMSettingMacsecMode = 0;
pub const NM_SETTING_MACSEC_MODE_EAP: NMSettingMacsecMode = 1;

pub type NMSettingMacsecValidation = c_int;
pub const NM_SETTING_MACSEC_VALIDATION_DISABLE: NMSettingMacsecValidation = 0;
pub const NM_SETTING_MACSEC_VALIDATION_CHECK: NMSettingMacsecValidation = 1;
pub const NM_SETTING_MACSEC_VALIDATION_STRICT: NMSettingMacsecValidation = 2;

pub type NMSettingMacvlanMode = c_int;
pub const NM_SETTING_MACVLAN_MODE_UNKNOWN: NMSettingMacvlanMode = 0;
pub const NM_SETTING_MACVLAN_MODE_VEPA: NMSettingMacvlanMode = 1;
pub const NM_SETTING_MACVLAN_MODE_BRIDGE: NMSettingMacvlanMode = 2;
pub const NM_SETTING_MACVLAN_MODE_PRIVATE: NMSettingMacvlanMode = 3;
pub const NM_SETTING_MACVLAN_MODE_PASSTHRU: NMSettingMacvlanMode = 4;
pub const NM_SETTING_MACVLAN_MODE_SOURCE: NMSettingMacvlanMode = 5;

pub type NMSettingProxyMethod = c_int;
pub const NM_SETTING_PROXY_METHOD_NONE: NMSettingProxyMethod = 0;
pub const NM_SETTING_PROXY_METHOD_AUTO: NMSettingProxyMethod = 1;

pub type NMSettingSerialParity = c_int;
pub const NM_SETTING_SERIAL_PARITY_NONE: NMSettingSerialParity = 0;
pub const NM_SETTING_SERIAL_PARITY_EVEN: NMSettingSerialParity = 1;
pub const NM_SETTING_SERIAL_PARITY_ODD: NMSettingSerialParity = 2;

pub type NMSettingTunMode = c_int;
pub const NM_SETTING_TUN_MODE_UNKNOWN: NMSettingTunMode = 0;
pub const NM_SETTING_TUN_MODE_TUN: NMSettingTunMode = 1;
pub const NM_SETTING_TUN_MODE_TAP: NMSettingTunMode = 2;

pub type NMSettingWirelessPowersave = c_int;
pub const NM_SETTING_WIRELESS_POWERSAVE_DEFAULT: NMSettingWirelessPowersave = 0;
pub const NM_SETTING_WIRELESS_POWERSAVE_IGNORE: NMSettingWirelessPowersave = 1;
pub const NM_SETTING_WIRELESS_POWERSAVE_DISABLE: NMSettingWirelessPowersave = 2;
pub const NM_SETTING_WIRELESS_POWERSAVE_ENABLE: NMSettingWirelessPowersave = 3;

pub type NMSettingsError = c_int;
pub const NM_SETTINGS_ERROR_FAILED: NMSettingsError = 0;
pub const NM_SETTINGS_ERROR_PERMISSION_DENIED: NMSettingsError = 1;
pub const NM_SETTINGS_ERROR_NOT_SUPPORTED: NMSettingsError = 2;
pub const NM_SETTINGS_ERROR_INVALID_CONNECTION: NMSettingsError = 3;
pub const NM_SETTINGS_ERROR_READ_ONLY_CONNECTION: NMSettingsError = 4;
pub const NM_SETTINGS_ERROR_UUID_EXISTS: NMSettingsError = 5;
pub const NM_SETTINGS_ERROR_INVALID_HOSTNAME: NMSettingsError = 6;

pub type NMState = c_int;
pub const NM_STATE_UNKNOWN: NMState = 0;
pub const NM_STATE_ASLEEP: NMState = 10;
pub const NM_STATE_DISCONNECTED: NMState = 20;
pub const NM_STATE_DISCONNECTING: NMState = 30;
pub const NM_STATE_CONNECTING: NMState = 40;
pub const NM_STATE_CONNECTED_LOCAL: NMState = 50;
pub const NM_STATE_CONNECTED_SITE: NMState = 60;
pub const NM_STATE_CONNECTED_GLOBAL: NMState = 70;

pub type NMUtilsSecurityType = c_int;
pub const NMU_SEC_INVALID: NMUtilsSecurityType = 0;
pub const NMU_SEC_NONE: NMUtilsSecurityType = 1;
pub const NMU_SEC_STATIC_WEP: NMUtilsSecurityType = 2;
pub const NMU_SEC_LEAP: NMUtilsSecurityType = 3;
pub const NMU_SEC_DYNAMIC_WEP: NMUtilsSecurityType = 4;
pub const NMU_SEC_WPA_PSK: NMUtilsSecurityType = 5;
pub const NMU_SEC_WPA_ENTERPRISE: NMUtilsSecurityType = 6;
pub const NMU_SEC_WPA2_PSK: NMUtilsSecurityType = 7;
pub const NMU_SEC_WPA2_ENTERPRISE: NMUtilsSecurityType = 8;

pub type NMVlanPriorityMap = c_int;
pub const NM_VLAN_INGRESS_MAP: NMVlanPriorityMap = 0;
pub const NM_VLAN_EGRESS_MAP: NMVlanPriorityMap = 1;

pub type NMVpnConnectionState = c_int;
pub const NM_VPN_CONNECTION_STATE_UNKNOWN: NMVpnConnectionState = 0;
pub const NM_VPN_CONNECTION_STATE_PREPARE: NMVpnConnectionState = 1;
pub const NM_VPN_CONNECTION_STATE_NEED_AUTH: NMVpnConnectionState = 2;
pub const NM_VPN_CONNECTION_STATE_CONNECT: NMVpnConnectionState = 3;
pub const NM_VPN_CONNECTION_STATE_IP_CONFIG_GET: NMVpnConnectionState = 4;
pub const NM_VPN_CONNECTION_STATE_ACTIVATED: NMVpnConnectionState = 5;
pub const NM_VPN_CONNECTION_STATE_FAILED: NMVpnConnectionState = 6;
pub const NM_VPN_CONNECTION_STATE_DISCONNECTED: NMVpnConnectionState = 7;

pub type NMVpnConnectionStateReason = c_int;
pub const NM_VPN_CONNECTION_STATE_REASON_UNKNOWN: NMVpnConnectionStateReason = 0;
pub const NM_VPN_CONNECTION_STATE_REASON_NONE: NMVpnConnectionStateReason = 1;
pub const NM_VPN_CONNECTION_STATE_REASON_USER_DISCONNECTED: NMVpnConnectionStateReason = 2;
pub const NM_VPN_CONNECTION_STATE_REASON_DEVICE_DISCONNECTED: NMVpnConnectionStateReason = 3;
pub const NM_VPN_CONNECTION_STATE_REASON_SERVICE_STOPPED: NMVpnConnectionStateReason = 4;
pub const NM_VPN_CONNECTION_STATE_REASON_IP_CONFIG_INVALID: NMVpnConnectionStateReason = 5;
pub const NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT: NMVpnConnectionStateReason = 6;
pub const NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_TIMEOUT: NMVpnConnectionStateReason = 7;
pub const NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED: NMVpnConnectionStateReason = 8;
pub const NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS: NMVpnConnectionStateReason = 9;
pub const NM_VPN_CONNECTION_STATE_REASON_LOGIN_FAILED: NMVpnConnectionStateReason = 10;
pub const NM_VPN_CONNECTION_STATE_REASON_CONNECTION_REMOVED: NMVpnConnectionStateReason = 11;

pub type NMVpnPluginError = c_int;
pub const NM_VPN_PLUGIN_ERROR_FAILED: NMVpnPluginError = 0;
pub const NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS: NMVpnPluginError = 1;
pub const NM_VPN_PLUGIN_ERROR_ALREADY_STARTED: NMVpnPluginError = 2;
pub const NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS: NMVpnPluginError = 3;
pub const NM_VPN_PLUGIN_ERROR_ALREADY_STOPPED: NMVpnPluginError = 4;
pub const NM_VPN_PLUGIN_ERROR_WRONG_STATE: NMVpnPluginError = 5;
pub const NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS: NMVpnPluginError = 6;
pub const NM_VPN_PLUGIN_ERROR_LAUNCH_FAILED: NMVpnPluginError = 7;
pub const NM_VPN_PLUGIN_ERROR_INVALID_CONNECTION: NMVpnPluginError = 8;
pub const NM_VPN_PLUGIN_ERROR_INTERACTIVE_NOT_SUPPORTED: NMVpnPluginError = 9;

pub type NMVpnPluginFailure = c_int;
pub const NM_VPN_PLUGIN_FAILURE_LOGIN_FAILED: NMVpnPluginFailure = 0;
pub const NM_VPN_PLUGIN_FAILURE_CONNECT_FAILED: NMVpnPluginFailure = 1;
pub const NM_VPN_PLUGIN_FAILURE_BAD_IP_CONFIG: NMVpnPluginFailure = 2;

pub type NMVpnServiceState = c_int;
pub const NM_VPN_SERVICE_STATE_UNKNOWN: NMVpnServiceState = 0;
pub const NM_VPN_SERVICE_STATE_INIT: NMVpnServiceState = 1;
pub const NM_VPN_SERVICE_STATE_SHUTDOWN: NMVpnServiceState = 2;
pub const NM_VPN_SERVICE_STATE_STARTING: NMVpnServiceState = 3;
pub const NM_VPN_SERVICE_STATE_STARTED: NMVpnServiceState = 4;
pub const NM_VPN_SERVICE_STATE_STOPPING: NMVpnServiceState = 5;
pub const NM_VPN_SERVICE_STATE_STOPPED: NMVpnServiceState = 6;

pub type NMWepKeyType = c_int;
pub const NM_WEP_KEY_TYPE_UNKNOWN: NMWepKeyType = 0;
pub const NM_WEP_KEY_TYPE_KEY: NMWepKeyType = 1;
pub const NM_WEP_KEY_TYPE_PASSPHRASE: NMWepKeyType = 2;

pub type NMWimaxNspNetworkType = c_int;
pub const NM_WIMAX_NSP_NETWORK_TYPE_UNKNOWN: NMWimaxNspNetworkType = 0;
pub const NM_WIMAX_NSP_NETWORK_TYPE_HOME: NMWimaxNspNetworkType = 1;
pub const NM_WIMAX_NSP_NETWORK_TYPE_PARTNER: NMWimaxNspNetworkType = 2;
pub const NM_WIMAX_NSP_NETWORK_TYPE_ROAMING_PARTNER: NMWimaxNspNetworkType = 3;

// Constants
pub const NM_ACCESS_POINT_BSSID: *const c_char = b"bssid\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_FLAGS: *const c_char = b"flags\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_FREQUENCY: *const c_char = b"frequency\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_LAST_SEEN: *const c_char = b"last-seen\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_MAX_BITRATE: *const c_char = b"max-bitrate\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_RSN_FLAGS: *const c_char = b"rsn-flags\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_SSID: *const c_char = b"ssid\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_STRENGTH: *const c_char = b"strength\0" as *const u8 as *const c_char;
pub const NM_ACCESS_POINT_WPA_FLAGS: *const c_char = b"wpa-flags\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_CONNECTION: *const c_char = b"connection\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_DEFAULT: *const c_char = b"default\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_DEFAULT6: *const c_char = b"default6\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_DEVICES: *const c_char = b"devices\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_DHCP4_CONFIG: *const c_char = b"dhcp4-config\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_DHCP6_CONFIG: *const c_char = b"dhcp6-config\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_ID: *const c_char = b"id\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_IP4_CONFIG: *const c_char = b"ip4-config\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_IP6_CONFIG: *const c_char = b"ip6-config\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_MASTER: *const c_char = b"master\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_SPECIFIC_OBJECT_PATH: *const c_char = b"specific-object-path\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_STATE: *const c_char = b"state\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_TYPE: *const c_char = b"type\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_UUID: *const c_char = b"uuid\0" as *const u8 as *const c_char;
pub const NM_ACTIVE_CONNECTION_VPN: *const c_char = b"vpn\0" as *const u8 as *const c_char;
pub const NM_CLIENT_ACTIVATING_CONNECTION: *const c_char = b"activating-connection\0" as *const u8 as *const c_char;
pub const NM_CLIENT_ACTIVE_CONNECTIONS: *const c_char = b"active-connections\0" as *const u8 as *const c_char;
pub const NM_CLIENT_ACTIVE_CONNECTION_ADDED: *const c_char = b"active-connection-added\0" as *const u8 as *const c_char;
pub const NM_CLIENT_ACTIVE_CONNECTION_REMOVED: *const c_char = b"active-connection-removed\0" as *const u8 as *const c_char;
pub const NM_CLIENT_ALL_DEVICES: *const c_char = b"all-devices\0" as *const u8 as *const c_char;
pub const NM_CLIENT_ANY_DEVICE_ADDED: *const c_char = b"any-device-added\0" as *const u8 as *const c_char;
pub const NM_CLIENT_ANY_DEVICE_REMOVED: *const c_char = b"any-device-removed\0" as *const u8 as *const c_char;
pub const NM_CLIENT_CAN_MODIFY: *const c_char = b"can-modify\0" as *const u8 as *const c_char;
pub const NM_CLIENT_CONNECTIONS: *const c_char = b"connections\0" as *const u8 as *const c_char;
pub const NM_CLIENT_CONNECTION_ADDED: *const c_char = b"connection-added\0" as *const u8 as *const c_char;
pub const NM_CLIENT_CONNECTION_REMOVED: *const c_char = b"connection-removed\0" as *const u8 as *const c_char;
pub const NM_CLIENT_CONNECTIVITY: *const c_char = b"connectivity\0" as *const u8 as *const c_char;
pub const NM_CLIENT_DEVICES: *const c_char = b"devices\0" as *const u8 as *const c_char;
pub const NM_CLIENT_DEVICE_ADDED: *const c_char = b"device-added\0" as *const u8 as *const c_char;
pub const NM_CLIENT_DEVICE_REMOVED: *const c_char = b"device-removed\0" as *const u8 as *const c_char;
pub const NM_CLIENT_DNS_CONFIGURATION: *const c_char = b"dns-configuration\0" as *const u8 as *const c_char;
pub const NM_CLIENT_DNS_MODE: *const c_char = b"dns-mode\0" as *const u8 as *const c_char;
pub const NM_CLIENT_DNS_RC_MANAGER: *const c_char = b"dns-rc-manager\0" as *const u8 as *const c_char;
pub const NM_CLIENT_HOSTNAME: *const c_char = b"hostname\0" as *const u8 as *const c_char;
pub const NM_CLIENT_METERED: *const c_char = b"metered\0" as *const u8 as *const c_char;
pub const NM_CLIENT_NETWORKING_ENABLED: *const c_char = b"networking-enabled\0" as *const u8 as *const c_char;
pub const NM_CLIENT_NM_RUNNING: *const c_char = b"nm-running\0" as *const u8 as *const c_char;
pub const NM_CLIENT_PERMISSION_CHANGED: *const c_char = b"permission-changed\0" as *const u8 as *const c_char;
pub const NM_CLIENT_PRIMARY_CONNECTION: *const c_char = b"primary-connection\0" as *const u8 as *const c_char;
pub const NM_CLIENT_STARTUP: *const c_char = b"startup\0" as *const u8 as *const c_char;
pub const NM_CLIENT_STATE: *const c_char = b"state\0" as *const u8 as *const c_char;
pub const NM_CLIENT_VERSION: *const c_char = b"version\0" as *const u8 as *const c_char;
pub const NM_CLIENT_WIMAX_ENABLED: *const c_char = b"wimax-enabled\0" as *const u8 as *const c_char;
pub const NM_CLIENT_WIMAX_HARDWARE_ENABLED: *const c_char = b"wimax-hardware-enabled\0" as *const u8 as *const c_char;
pub const NM_CLIENT_WIRELESS_ENABLED: *const c_char = b"wireless-enabled\0" as *const u8 as *const c_char;
pub const NM_CLIENT_WIRELESS_HARDWARE_ENABLED: *const c_char = b"wireless-hardware-enabled\0" as *const u8 as *const c_char;
pub const NM_CLIENT_WWAN_ENABLED: *const c_char = b"wwan-enabled\0" as *const u8 as *const c_char;
pub const NM_CLIENT_WWAN_HARDWARE_ENABLED: *const c_char = b"wwan-hardware-enabled\0" as *const u8 as *const c_char;
pub const NM_CONNECTION_CHANGED: *const c_char = b"changed\0" as *const u8 as *const c_char;
pub const NM_CONNECTION_NORMALIZE_PARAM_IP6_CONFIG_METHOD: *const c_char = b"ip6-config-method\0" as *const u8 as *const c_char;
pub const NM_CONNECTION_SECRETS_CLEARED: *const c_char = b"secrets-cleared\0" as *const u8 as *const c_char;
pub const NM_CONNECTION_SECRETS_UPDATED: *const c_char = b"secrets-updated\0" as *const u8 as *const c_char;
pub const NM_DBUS_INTERFACE: *const c_char = b"org.freedesktop.NetworkManager\0" as *const u8 as *const c_char;
pub const NM_DBUS_INTERFACE_DNS_MANAGER: *const c_char = b"org.freedesktop.NetworkManager.DnsManager\0" as *const u8 as *const c_char;
pub const NM_DBUS_INTERFACE_SETTINGS: *const c_char = b"org.freedesktop.NetworkManager.Settings\0" as *const u8 as *const c_char;
pub const NM_DBUS_INTERFACE_SETTINGS_CONNECTION: *const c_char = b"org.freedesktop.NetworkManager.Settings.Connection\0" as *const u8 as *const c_char;
pub const NM_DBUS_INTERFACE_SETTINGS_CONNECTION_SECRETS: *const c_char = b"org.freedesktop.NetworkManager.Settings.Connection.Secrets\0" as *const u8 as *const c_char;
pub const NM_DBUS_INTERFACE_VPN: *const c_char = b"org.freedesktop.NetworkManager.VPN.Manager\0" as *const u8 as *const c_char;
pub const NM_DBUS_INTERFACE_VPN_CONNECTION: *const c_char = b"org.freedesktop.NetworkManager.VPN.Connection\0" as *const u8 as *const c_char;
pub const NM_DBUS_INVALID_VPN_CONNECTION: *const c_char = b"org.freedesktop.NetworkManager.VPNConnections.InvalidVPNConnection\0" as *const u8 as *const c_char;
pub const NM_DBUS_NO_ACTIVE_VPN_CONNECTION: *const c_char = b"org.freedesktop.NetworkManager.VPNConnections.NoActiveVPNConnection\0" as *const u8 as *const c_char;
pub const NM_DBUS_NO_VPN_CONNECTIONS: *const c_char = b"org.freedesktop.NetworkManager.VPNConnections.NoVPNConnections\0" as *const u8 as *const c_char;
pub const NM_DBUS_PATH: *const c_char = b"/org/freedesktop/NetworkManager\0" as *const u8 as *const c_char;
pub const NM_DBUS_PATH_AGENT_MANAGER: *const c_char = b"/org/freedesktop/NetworkManager/AgentManager\0" as *const u8 as *const c_char;
pub const NM_DBUS_PATH_DNS_MANAGER: *const c_char = b"/org/freedesktop/NetworkManager/DnsManager\0" as *const u8 as *const c_char;
pub const NM_DBUS_PATH_SECRET_AGENT: *const c_char = b"/org/freedesktop/NetworkManager/SecretAgent\0" as *const u8 as *const c_char;
pub const NM_DBUS_PATH_SETTINGS: *const c_char = b"/org/freedesktop/NetworkManager/Settings\0" as *const u8 as *const c_char;
pub const NM_DBUS_PATH_SETTINGS_CONNECTION: *const c_char = b"/org/freedesktop/NetworkManager/Settings/Connection\0" as *const u8 as *const c_char;
pub const NM_DBUS_PATH_VPN: *const c_char = b"/org/freedesktop/NetworkManager/VPN/Manager\0" as *const u8 as *const c_char;
pub const NM_DBUS_PATH_VPN_CONNECTION: *const c_char = b"/org/freedesktop/NetworkManager/VPN/Connection\0" as *const u8 as *const c_char;
pub const NM_DBUS_SERVICE: *const c_char = b"org.freedesktop.NetworkManager\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_ALREADY_STARTED: *const c_char = b"AlreadyStarted\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_ALREADY_STOPPED: *const c_char = b"AlreadyStopped\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_BAD_ARGUMENTS: *const c_char = b"BadArguments\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_ERROR_PREFIX: *const c_char = b"org.freedesktop.NetworkManager.VPN.Error\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_INTERACTIVE_NOT_SUPPORTED: *const c_char = b"InteractiveNotSupported\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_SIGNAL_CONNECT_FAILED: *const c_char = b"ConnectFailed\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_SIGNAL_IP4_CONFIG: *const c_char = b"IP4Config\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_SIGNAL_IP_CONFIG_BAD: *const c_char = b"IPConfigBad\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_SIGNAL_LAUNCH_FAILED: *const c_char = b"LaunchFailed\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_SIGNAL_LOGIN_BANNER: *const c_char = b"LoginBanner\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_SIGNAL_LOGIN_FAILED: *const c_char = b"LoginFailed\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_SIGNAL_STATE_CHANGE: *const c_char = b"StateChange\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_SIGNAL_VPN_CONFIG_BAD: *const c_char = b"VPNConfigBad\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_STARTING_IN_PROGRESS: *const c_char = b"StartingInProgress\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_STOPPING_IN_PROGRESS: *const c_char = b"StoppingInProgress\0" as *const u8 as *const c_char;
pub const NM_DBUS_VPN_WRONG_STATE: *const c_char = b"WrongState\0" as *const u8 as *const c_char;
pub const NM_DEVICE_ACTIVE_CONNECTION: *const c_char = b"active-connection\0" as *const u8 as *const c_char;
pub const NM_DEVICE_ADSL_CARRIER: *const c_char = b"carrier\0" as *const u8 as *const c_char;
pub const NM_DEVICE_AUTOCONNECT: *const c_char = b"autoconnect\0" as *const u8 as *const c_char;
pub const NM_DEVICE_AVAILABLE_CONNECTIONS: *const c_char = b"available-connections\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BOND_CARRIER: *const c_char = b"carrier\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BOND_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BOND_SLAVES: *const c_char = b"slaves\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BRIDGE_CARRIER: *const c_char = b"carrier\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BRIDGE_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BRIDGE_SLAVES: *const c_char = b"slaves\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BT_CAPABILITIES: *const c_char = b"bt-capabilities\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BT_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_BT_NAME: *const c_char = b"name\0" as *const u8 as *const c_char;
pub const NM_DEVICE_CAPABILITIES: *const c_char = b"capabilities\0" as *const u8 as *const c_char;
pub const NM_DEVICE_DEVICE_TYPE: *const c_char = b"device-type\0" as *const u8 as *const c_char;
pub const NM_DEVICE_DHCP4_CONFIG: *const c_char = b"dhcp4-config\0" as *const u8 as *const c_char;
pub const NM_DEVICE_DHCP6_CONFIG: *const c_char = b"dhcp6-config\0" as *const u8 as *const c_char;
pub const NM_DEVICE_DRIVER: *const c_char = b"driver\0" as *const u8 as *const c_char;
pub const NM_DEVICE_DRIVER_VERSION: *const c_char = b"driver-version\0" as *const u8 as *const c_char;
pub const NM_DEVICE_ETHERNET_CARRIER: *const c_char = b"carrier\0" as *const u8 as *const c_char;
pub const NM_DEVICE_ETHERNET_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_ETHERNET_PERMANENT_HW_ADDRESS: *const c_char = b"perm-hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_ETHERNET_S390_SUBCHANNELS: *const c_char = b"s390-subchannels\0" as *const u8 as *const c_char;
pub const NM_DEVICE_ETHERNET_SPEED: *const c_char = b"speed\0" as *const u8 as *const c_char;
pub const NM_DEVICE_FIRMWARE_MISSING: *const c_char = b"firmware-missing\0" as *const u8 as *const c_char;
pub const NM_DEVICE_FIRMWARE_VERSION: *const c_char = b"firmware-version\0" as *const u8 as *const c_char;
pub const NM_DEVICE_GENERIC_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_GENERIC_TYPE_DESCRIPTION: *const c_char = b"type-description\0" as *const u8 as *const c_char;
pub const NM_DEVICE_INFINIBAND_CARRIER: *const c_char = b"carrier\0" as *const u8 as *const c_char;
pub const NM_DEVICE_INFINIBAND_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_INTERFACE: *const c_char = b"interface\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP4_CONFIG: *const c_char = b"ip4-config\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP6_CONFIG: *const c_char = b"ip6-config\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_INTERFACE: *const c_char = b"ip-interface\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_ENCAPSULATION_LIMIT: *const c_char = b"encapsulation-limit\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_FLOW_LABEL: *const c_char = b"flow-label\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_INPUT_KEY: *const c_char = b"input-key\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_LOCAL: *const c_char = b"local\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_OUTPUT_KEY: *const c_char = b"output-key\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_PATH_MTU_DISCOVERY: *const c_char = b"path-mtu-discovery\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_REMOTE: *const c_char = b"remote\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_TOS: *const c_char = b"tos\0" as *const u8 as *const c_char;
pub const NM_DEVICE_IP_TUNNEL_TTL: *const c_char = b"ttl\0" as *const u8 as *const c_char;
pub const NM_DEVICE_LLDP_NEIGHBORS: *const c_char = b"lldp-neighbors\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_CIPHER_SUITE: *const c_char = b"cipher-suite\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_ENCODING_SA: *const c_char = b"encoding-sa\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_ENCRYPT: *const c_char = b"encrypt\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_ES: *const c_char = b"es\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_ICV_LENGTH: *const c_char = b"icv-length\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_INCLUDE_SCI: *const c_char = b"include-sci\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_PROTECT: *const c_char = b"protect\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_REPLAY_PROTECT: *const c_char = b"replay-protect\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_SCB: *const c_char = b"scb\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_SCI: *const c_char = b"sci\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_VALIDATION: *const c_char = b"validation\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACSEC_WINDOW: *const c_char = b"window\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACVLAN_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACVLAN_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACVLAN_NO_PROMISC: *const c_char = b"no-promisc\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACVLAN_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MACVLAN_TAP: *const c_char = b"tap\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MANAGED: *const c_char = b"managed\0" as *const u8 as *const c_char;
pub const NM_DEVICE_METERED: *const c_char = b"metered\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MODEM_CURRENT_CAPABILITIES: *const c_char = b"current-capabilities\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MODEM_MODEM_CAPABILITIES: *const c_char = b"modem-capabilities\0" as *const u8 as *const c_char;
pub const NM_DEVICE_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_DEVICE_NM_PLUGIN_MISSING: *const c_char = b"nm-plugin-missing\0" as *const u8 as *const c_char;
pub const NM_DEVICE_OLPC_MESH_ACTIVE_CHANNEL: *const c_char = b"active-channel\0" as *const u8 as *const c_char;
pub const NM_DEVICE_OLPC_MESH_COMPANION: *const c_char = b"companion\0" as *const u8 as *const c_char;
pub const NM_DEVICE_OLPC_MESH_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_PHYSICAL_PORT_ID: *const c_char = b"physical-port-id\0" as *const u8 as *const c_char;
pub const NM_DEVICE_PRODUCT: *const c_char = b"product\0" as *const u8 as *const c_char;
pub const NM_DEVICE_REAL: *const c_char = b"real\0" as *const u8 as *const c_char;
pub const NM_DEVICE_STATE: *const c_char = b"state\0" as *const u8 as *const c_char;
pub const NM_DEVICE_STATE_REASON: *const c_char = b"state-reason\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TEAM_CARRIER: *const c_char = b"carrier\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TEAM_CONFIG: *const c_char = b"config\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TEAM_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TEAM_SLAVES: *const c_char = b"slaves\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TUN_GROUP: *const c_char = b"group\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TUN_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TUN_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TUN_MULTI_QUEUE: *const c_char = b"multi-queue\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TUN_NO_PI: *const c_char = b"no-pi\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TUN_OWNER: *const c_char = b"owner\0" as *const u8 as *const c_char;
pub const NM_DEVICE_TUN_VNET_HDR: *const c_char = b"vnet-hdr\0" as *const u8 as *const c_char;
pub const NM_DEVICE_UDI: *const c_char = b"udi\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VENDOR: *const c_char = b"vendor\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VLAN_CARRIER: *const c_char = b"carrier\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VLAN_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VLAN_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VLAN_VLAN_ID: *const c_char = b"vlan-id\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_AGEING: *const c_char = b"ageing\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_CARRIER: *const c_char = b"carrier\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_DST_PORT: *const c_char = b"dst-port\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_GROUP: *const c_char = b"group\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_ID: *const c_char = b"id\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_L2MISS: *const c_char = b"l2miss\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_L3MISS: *const c_char = b"l3miss\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_LEARNING: *const c_char = b"learning\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_LIMIT: *const c_char = b"limit\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_LOCAL: *const c_char = b"local\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_PROXY: *const c_char = b"proxy\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_RSC: *const c_char = b"rsc\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_SRC_PORT_MAX: *const c_char = b"src-port-max\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_SRC_PORT_MIN: *const c_char = b"src-port-min\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_TOS: *const c_char = b"tos\0" as *const u8 as *const c_char;
pub const NM_DEVICE_VXLAN_TTL: *const c_char = b"ttl\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_ACCESS_POINTS: *const c_char = b"access-points\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_ACTIVE_ACCESS_POINT: *const c_char = b"active-access-point\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_BITRATE: *const c_char = b"bitrate\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_CAPABILITIES: *const c_char = b"wireless-capabilities\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIFI_PERMANENT_HW_ADDRESS: *const c_char = b"perm-hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIMAX_ACTIVE_NSP: *const c_char = b"active-nsp\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIMAX_BSID: *const c_char = b"bsid\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIMAX_CENTER_FREQUENCY: *const c_char = b"center-frequency\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIMAX_CINR: *const c_char = b"cinr\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIMAX_HW_ADDRESS: *const c_char = b"hw-address\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIMAX_NSPS: *const c_char = b"nsps\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIMAX_RSSI: *const c_char = b"rssi\0" as *const u8 as *const c_char;
pub const NM_DEVICE_WIMAX_TX_POWER: *const c_char = b"tx-power\0" as *const u8 as *const c_char;
pub const NM_DHCP_CONFIG_FAMILY: *const c_char = b"family\0" as *const u8 as *const c_char;
pub const NM_DHCP_CONFIG_OPTIONS: *const c_char = b"options\0" as *const u8 as *const c_char;
pub const NM_IP_CONFIG_ADDRESSES: *const c_char = b"addresses\0" as *const u8 as *const c_char;
pub const NM_IP_CONFIG_DOMAINS: *const c_char = b"domains\0" as *const u8 as *const c_char;
pub const NM_IP_CONFIG_FAMILY: *const c_char = b"family\0" as *const u8 as *const c_char;
pub const NM_IP_CONFIG_GATEWAY: *const c_char = b"gateway\0" as *const u8 as *const c_char;
pub const NM_IP_CONFIG_NAMESERVERS: *const c_char = b"nameservers\0" as *const u8 as *const c_char;
pub const NM_IP_CONFIG_ROUTES: *const c_char = b"routes\0" as *const u8 as *const c_char;
pub const NM_IP_CONFIG_SEARCHES: *const c_char = b"searches\0" as *const u8 as *const c_char;
pub const NM_IP_CONFIG_WINS_SERVERS: *const c_char = b"wins-servers\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_CWND: *const c_char = b"cwnd\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_FROM: *const c_char = b"from\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_INITCWND: *const c_char = b"initcwnd\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_INITRWND: *const c_char = b"initrwnd\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_CWND: *const c_char = b"lock-cwnd\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_INITCWND: *const c_char = b"lock-initcwnd\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_INITRWND: *const c_char = b"lock-initrwnd\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_MTU: *const c_char = b"lock-mtu\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_LOCK_WINDOW: *const c_char = b"lock-window\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_SRC: *const c_char = b"src\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_TOS: *const c_char = b"tos\0" as *const u8 as *const c_char;
pub const NM_IP_ROUTE_ATTRIBUTE_WINDOW: *const c_char = b"window\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_CHASSIS_ID: *const c_char = b"chassis-id\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_CHASSIS_ID_TYPE: *const c_char = b"chassis-id-type\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_DESTINATION: *const c_char = b"destination\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_IEEE_802_1_PPVID: *const c_char = b"ieee-802-1-ppvid\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_IEEE_802_1_PPVID_FLAGS: *const c_char = b"ieee-802-1-ppvid-flags\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_IEEE_802_1_PVID: *const c_char = b"ieee-802-1-pvid\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_IEEE_802_1_VID: *const c_char = b"ieee-802-1-vid\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_IEEE_802_1_VLAN_NAME: *const c_char = b"ieee-802-1-vlan-name\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_PORT_DESCRIPTION: *const c_char = b"port-description\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_PORT_ID: *const c_char = b"port-id\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_PORT_ID_TYPE: *const c_char = b"port-id-type\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_SYSTEM_CAPABILITIES: *const c_char = b"system-capabilities\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_SYSTEM_DESCRIPTION: *const c_char = b"system-description\0" as *const u8 as *const c_char;
pub const NM_LLDP_ATTR_SYSTEM_NAME: *const c_char = b"system-name\0" as *const u8 as *const c_char;
pub const NM_LLDP_DEST_NEAREST_BRIDGE: *const c_char = b"nearest-bridge\0" as *const u8 as *const c_char;
pub const NM_LLDP_DEST_NEAREST_CUSTOMER_BRIDGE: *const c_char = b"nearest-customer-bridge\0" as *const u8 as *const c_char;
pub const NM_LLDP_DEST_NEAREST_NON_TPMR_BRIDGE: *const c_char = b"nearest-non-tpmr-bridge\0" as *const u8 as *const c_char;
pub const NM_MAJOR_VERSION: c_int = 1;
pub const NM_MICRO_VERSION: c_int = 6;
pub const NM_MINOR_VERSION: c_int = 8;
pub const NM_OBJECT_DBUS_CONNECTION: *const c_char = b"dbus-connection\0" as *const u8 as *const c_char;
pub const NM_OBJECT_DBUS_OBJECT: *const c_char = b"dbus-object\0" as *const u8 as *const c_char;
pub const NM_OBJECT_DBUS_OBJECT_MANAGER: *const c_char = b"dbus-object-manager\0" as *const u8 as *const c_char;
pub const NM_OBJECT_PATH: *const c_char = b"path\0" as *const u8 as *const c_char;
pub const NM_REMOTE_CONNECTION_DBUS_CONNECTION: *const c_char = b"dbus-connection\0" as *const u8 as *const c_char;
pub const NM_REMOTE_CONNECTION_PATH: *const c_char = b"path\0" as *const u8 as *const c_char;
pub const NM_REMOTE_CONNECTION_UNSAVED: *const c_char = b"unsaved\0" as *const u8 as *const c_char;
pub const NM_REMOTE_CONNECTION_VISIBLE: *const c_char = b"visible\0" as *const u8 as *const c_char;
pub const NM_SECRET_AGENT_OLD_AUTO_REGISTER: *const c_char = b"auto-register\0" as *const u8 as *const c_char;
pub const NM_SECRET_AGENT_OLD_CAPABILITIES: *const c_char = b"capabilities\0" as *const u8 as *const c_char;
pub const NM_SECRET_AGENT_OLD_IDENTIFIER: *const c_char = b"identifier\0" as *const u8 as *const c_char;
pub const NM_SECRET_AGENT_OLD_REGISTERED: *const c_char = b"registered\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_ALTSUBJECT_MATCHES: *const c_char = b"altsubject-matches\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_ANONYMOUS_IDENTITY: *const c_char = b"anonymous-identity\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_AUTH_TIMEOUT: *const c_char = b"auth-timeout\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CA_CERT: *const c_char = b"ca-cert\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CA_CERT_PASSWORD: *const c_char = b"ca-cert-password\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CA_CERT_PASSWORD_FLAGS: *const c_char = b"ca-cert-password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CA_PATH: *const c_char = b"ca-path\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CERT_SCHEME_PREFIX_PATH: *const c_char = b"file://\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CERT_SCHEME_PREFIX_PKCS11: *const c_char = b"pkcs11:\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CLIENT_CERT: *const c_char = b"client-cert\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CLIENT_CERT_PASSWORD: *const c_char = b"client-cert-password\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_CLIENT_CERT_PASSWORD_FLAGS: *const c_char = b"client-cert-password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_DOMAIN_SUFFIX_MATCH: *const c_char = b"domain-suffix-match\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_EAP: *const c_char = b"eap\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_IDENTITY: *const c_char = b"identity\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PAC_FILE: *const c_char = b"pac-file\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PASSWORD: *const c_char = b"password\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PASSWORD_FLAGS: *const c_char = b"password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PASSWORD_RAW: *const c_char = b"password-raw\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PASSWORD_RAW_FLAGS: *const c_char = b"password-raw-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE1_AUTH_FLAGS: *const c_char = b"phase1-auth-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE1_FAST_PROVISIONING: *const c_char = b"phase1-fast-provisioning\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE1_PEAPLABEL: *const c_char = b"phase1-peaplabel\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE1_PEAPVER: *const c_char = b"phase1-peapver\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_ALTSUBJECT_MATCHES: *const c_char = b"phase2-altsubject-matches\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_AUTH: *const c_char = b"phase2-auth\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_AUTHEAP: *const c_char = b"phase2-autheap\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_CA_CERT: *const c_char = b"phase2-ca-cert\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_CA_CERT_PASSWORD: *const c_char = b"phase2-ca-cert-password\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_CA_CERT_PASSWORD_FLAGS: *const c_char = b"phase2-ca-cert-password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_CA_PATH: *const c_char = b"phase2-ca-path\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_CLIENT_CERT: *const c_char = b"phase2-client-cert\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD: *const c_char = b"phase2-client-cert-password\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_CLIENT_CERT_PASSWORD_FLAGS: *const c_char = b"phase2-client-cert-password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_DOMAIN_SUFFIX_MATCH: *const c_char = b"phase2-domain-suffix-match\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_PRIVATE_KEY: *const c_char = b"phase2-private-key\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD: *const c_char = b"phase2-private-key-password\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_PRIVATE_KEY_PASSWORD_FLAGS: *const c_char = b"phase2-private-key-password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PHASE2_SUBJECT_MATCH: *const c_char = b"phase2-subject-match\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PIN: *const c_char = b"pin\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PIN_FLAGS: *const c_char = b"pin-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PRIVATE_KEY: *const c_char = b"private-key\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD: *const c_char = b"private-key-password\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_PRIVATE_KEY_PASSWORD_FLAGS: *const c_char = b"private-key-password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_SETTING_NAME: *const c_char = b"802-1x\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_SUBJECT_MATCH: *const c_char = b"subject-match\0" as *const u8 as *const c_char;
pub const NM_SETTING_802_1X_SYSTEM_CA_CERTS: *const c_char = b"system-ca-certs\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_ENCAPSULATION: *const c_char = b"encapsulation\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_ENCAPSULATION_LLC: *const c_char = b"llc\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_ENCAPSULATION_VCMUX: *const c_char = b"vcmux\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_PASSWORD: *const c_char = b"password\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_PASSWORD_FLAGS: *const c_char = b"password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_PROTOCOL: *const c_char = b"protocol\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_PROTOCOL_IPOATM: *const c_char = b"ipoatm\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_PROTOCOL_PPPOA: *const c_char = b"pppoa\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_PROTOCOL_PPPOE: *const c_char = b"pppoe\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_SETTING_NAME: *const c_char = b"adsl\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_USERNAME: *const c_char = b"username\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_VCI: *const c_char = b"vci\0" as *const u8 as *const c_char;
pub const NM_SETTING_ADSL_VPI: *const c_char = b"vpi\0" as *const u8 as *const c_char;
pub const NM_SETTING_BLUETOOTH_BDADDR: *const c_char = b"bdaddr\0" as *const u8 as *const c_char;
pub const NM_SETTING_BLUETOOTH_SETTING_NAME: *const c_char = b"bluetooth\0" as *const u8 as *const c_char;
pub const NM_SETTING_BLUETOOTH_TYPE: *const c_char = b"type\0" as *const u8 as *const c_char;
pub const NM_SETTING_BLUETOOTH_TYPE_DUN: *const c_char = b"dun\0" as *const u8 as *const c_char;
pub const NM_SETTING_BLUETOOTH_TYPE_PANU: *const c_char = b"panu\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTIONS: *const c_char = b"options\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_ACTIVE_SLAVE: *const c_char = b"active_slave\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_AD_ACTOR_SYSTEM: *const c_char = b"ad_actor_system\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_AD_ACTOR_SYS_PRIO: *const c_char = b"ad_actor_sys_prio\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_AD_SELECT: *const c_char = b"ad_select\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_AD_USER_PORT_KEY: *const c_char = b"ad_user_port_key\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_ALL_SLAVES_ACTIVE: *const c_char = b"all_slaves_active\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_ARP_ALL_TARGETS: *const c_char = b"arp_all_targets\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_ARP_INTERVAL: *const c_char = b"arp_interval\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_ARP_IP_TARGET: *const c_char = b"arp_ip_target\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_ARP_VALIDATE: *const c_char = b"arp_validate\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_DOWNDELAY: *const c_char = b"downdelay\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_FAIL_OVER_MAC: *const c_char = b"fail_over_mac\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_LACP_RATE: *const c_char = b"lacp_rate\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_LP_INTERVAL: *const c_char = b"lp_interval\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_MIIMON: *const c_char = b"miimon\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_MIN_LINKS: *const c_char = b"min_links\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_NUM_GRAT_ARP: *const c_char = b"num_grat_arp\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_NUM_UNSOL_NA: *const c_char = b"num_unsol_na\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_PACKETS_PER_SLAVE: *const c_char = b"packets_per_slave\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_PRIMARY: *const c_char = b"primary\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_PRIMARY_RESELECT: *const c_char = b"primary_reselect\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_RESEND_IGMP: *const c_char = b"resend_igmp\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_TLB_DYNAMIC_LB: *const c_char = b"tlb_dynamic_lb\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_UPDELAY: *const c_char = b"updelay\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_USE_CARRIER: *const c_char = b"use_carrier\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_OPTION_XMIT_HASH_POLICY: *const c_char = b"xmit_hash_policy\0" as *const u8 as *const c_char;
pub const NM_SETTING_BOND_SETTING_NAME: *const c_char = b"bond\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_AGEING_TIME: *const c_char = b"ageing-time\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_FORWARD_DELAY: *const c_char = b"forward-delay\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_HELLO_TIME: *const c_char = b"hello-time\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_MAC_ADDRESS: *const c_char = b"mac-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_MAX_AGE: *const c_char = b"max-age\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_MULTICAST_SNOOPING: *const c_char = b"multicast-snooping\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE: *const c_char = b"hairpin-mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_PORT_PATH_COST: *const c_char = b"path-cost\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_PORT_PRIORITY: *const c_char = b"priority\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_PORT_SETTING_NAME: *const c_char = b"bridge-port\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_PRIORITY: *const c_char = b"priority\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_SETTING_NAME: *const c_char = b"bridge\0" as *const u8 as *const c_char;
pub const NM_SETTING_BRIDGE_STP: *const c_char = b"stp\0" as *const u8 as *const c_char;
pub const NM_SETTING_CDMA_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_SETTING_CDMA_NUMBER: *const c_char = b"number\0" as *const u8 as *const c_char;
pub const NM_SETTING_CDMA_PASSWORD: *const c_char = b"password\0" as *const u8 as *const c_char;
pub const NM_SETTING_CDMA_PASSWORD_FLAGS: *const c_char = b"password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_CDMA_SETTING_NAME: *const c_char = b"cdma\0" as *const u8 as *const c_char;
pub const NM_SETTING_CDMA_USERNAME: *const c_char = b"username\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_AUTOCONNECT: *const c_char = b"autoconnect\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY: *const c_char = b"autoconnect-priority\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_DEFAULT: c_int = 0;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MAX: c_int = 999;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_PRIORITY_MIN: c_int = -999;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_RETRIES: *const c_char = b"autoconnect-retries\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_AUTOCONNECT_SLAVES: *const c_char = b"autoconnect-slaves\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_GATEWAY_PING_TIMEOUT: *const c_char = b"gateway-ping-timeout\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_ID: *const c_char = b"id\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_INTERFACE_NAME: *const c_char = b"interface-name\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_LLDP: *const c_char = b"lldp\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_MASTER: *const c_char = b"master\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_METERED: *const c_char = b"metered\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_PERMISSIONS: *const c_char = b"permissions\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_READ_ONLY: *const c_char = b"read-only\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_SECONDARIES: *const c_char = b"secondaries\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_SETTING_NAME: *const c_char = b"connection\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_SLAVE_TYPE: *const c_char = b"slave-type\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_STABLE_ID: *const c_char = b"stable-id\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_TIMESTAMP: *const c_char = b"timestamp\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_TYPE: *const c_char = b"type\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_UUID: *const c_char = b"uuid\0" as *const u8 as *const c_char;
pub const NM_SETTING_CONNECTION_ZONE: *const c_char = b"zone\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_APP_FCOE_FLAGS: *const c_char = b"app-fcoe-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_APP_FCOE_MODE: *const c_char = b"app-fcoe-mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_APP_FCOE_PRIORITY: *const c_char = b"app-fcoe-priority\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_APP_FIP_FLAGS: *const c_char = b"app-fip-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_APP_FIP_PRIORITY: *const c_char = b"app-fip-priority\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_APP_ISCSI_FLAGS: *const c_char = b"app-iscsi-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_APP_ISCSI_PRIORITY: *const c_char = b"app-iscsi-priority\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_FCOE_MODE_FABRIC: *const c_char = b"fabric\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_FCOE_MODE_VN2VN: *const c_char = b"vn2vn\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_PRIORITY_BANDWIDTH: *const c_char = b"priority-bandwidth\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_PRIORITY_FLOW_CONTROL: *const c_char = b"priority-flow-control\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_PRIORITY_FLOW_CONTROL_FLAGS: *const c_char = b"priority-flow-control-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_PRIORITY_GROUP_BANDWIDTH: *const c_char = b"priority-group-bandwidth\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_PRIORITY_GROUP_FLAGS: *const c_char = b"priority-group-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_PRIORITY_GROUP_ID: *const c_char = b"priority-group-id\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_PRIORITY_STRICT_BANDWIDTH: *const c_char = b"priority-strict-bandwidth\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_PRIORITY_TRAFFIC_CLASS: *const c_char = b"priority-traffic-class\0" as *const u8 as *const c_char;
pub const NM_SETTING_DCB_SETTING_NAME: *const c_char = b"dcb\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_ATTEMPTS: *const c_char = b"attempts\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_DEBUG: *const c_char = b"debug\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_EDNS0: *const c_char = b"edns0\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_INET6: *const c_char = b"inet6\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_IP6_BYTESTRING: *const c_char = b"ip6-bytestring\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_IP6_DOTINT: *const c_char = b"ip6-dotint\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_NDOTS: *const c_char = b"ndots\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_NO_CHECK_NAMES: *const c_char = b"no-check-names\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_NO_IP6_DOTINT: *const c_char = b"no-ip6-dotint\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_NO_TLD_QUERY: *const c_char = b"no-tld-query\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_ROTATE: *const c_char = b"rotate\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_SINGLE_REQUEST: *const c_char = b"single-request\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_SINGLE_REQUEST_REOPEN: *const c_char = b"single-request-reopen\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_TIMEOUT: *const c_char = b"timeout\0" as *const u8 as *const c_char;
pub const NM_SETTING_DNS_OPTION_USE_VC: *const c_char = b"use-vc\0" as *const u8 as *const c_char;
pub const NM_SETTING_DUMMY_SETTING_NAME: *const c_char = b"dummy\0" as *const u8 as *const c_char;
pub const NM_SETTING_GENERIC_SETTING_NAME: *const c_char = b"generic\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_APN: *const c_char = b"apn\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_DEVICE_ID: *const c_char = b"device-id\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_HOME_ONLY: *const c_char = b"home-only\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_NETWORK_ID: *const c_char = b"network-id\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_NUMBER: *const c_char = b"number\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_PASSWORD: *const c_char = b"password\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_PASSWORD_FLAGS: *const c_char = b"password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_PIN: *const c_char = b"pin\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_PIN_FLAGS: *const c_char = b"pin-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_SETTING_NAME: *const c_char = b"gsm\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_SIM_ID: *const c_char = b"sim-id\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_SIM_OPERATOR_ID: *const c_char = b"sim-operator-id\0" as *const u8 as *const c_char;
pub const NM_SETTING_GSM_USERNAME: *const c_char = b"username\0" as *const u8 as *const c_char;
pub const NM_SETTING_INFINIBAND_MAC_ADDRESS: *const c_char = b"mac-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_INFINIBAND_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_SETTING_INFINIBAND_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_SETTING_INFINIBAND_P_KEY: *const c_char = b"p-key\0" as *const u8 as *const c_char;
pub const NM_SETTING_INFINIBAND_SETTING_NAME: *const c_char = b"infiniband\0" as *const u8 as *const c_char;
pub const NM_SETTING_INFINIBAND_TRANSPORT_MODE: *const c_char = b"transport-mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP4_CONFIG_DHCP_CLIENT_ID: *const c_char = b"dhcp-client-id\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP4_CONFIG_DHCP_FQDN: *const c_char = b"dhcp-fqdn\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP4_CONFIG_METHOD_AUTO: *const c_char = b"auto\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP4_CONFIG_METHOD_DISABLED: *const c_char = b"disabled\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL: *const c_char = b"link-local\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP4_CONFIG_METHOD_MANUAL: *const c_char = b"manual\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP4_CONFIG_METHOD_SHARED: *const c_char = b"shared\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP4_CONFIG_SETTING_NAME: *const c_char = b"ipv4\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_ADDR_GEN_MODE: *const c_char = b"addr-gen-mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_IP6_PRIVACY: *const c_char = b"ip6-privacy\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_METHOD_AUTO: *const c_char = b"auto\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_METHOD_DHCP: *const c_char = b"dhcp\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_METHOD_IGNORE: *const c_char = b"ignore\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL: *const c_char = b"link-local\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_METHOD_MANUAL: *const c_char = b"manual\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_METHOD_SHARED: *const c_char = b"shared\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_SETTING_NAME: *const c_char = b"ipv6\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP6_CONFIG_TOKEN: *const c_char = b"token\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_ADDRESSES: *const c_char = b"addresses\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DAD_TIMEOUT: *const c_char = b"dad-timeout\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DAD_TIMEOUT_MAX: c_int = 30000;
pub const NM_SETTING_IP_CONFIG_DHCP_HOSTNAME: *const c_char = b"dhcp-hostname\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DHCP_SEND_HOSTNAME: *const c_char = b"dhcp-send-hostname\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DHCP_TIMEOUT: *const c_char = b"dhcp-timeout\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DNS: *const c_char = b"dns\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DNS_OPTIONS: *const c_char = b"dns-options\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DNS_PRIORITY: *const c_char = b"dns-priority\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_DNS_SEARCH: *const c_char = b"dns-search\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_GATEWAY: *const c_char = b"gateway\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_IGNORE_AUTO_DNS: *const c_char = b"ignore-auto-dns\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_IGNORE_AUTO_ROUTES: *const c_char = b"ignore-auto-routes\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_MAY_FAIL: *const c_char = b"may-fail\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_METHOD: *const c_char = b"method\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_NEVER_DEFAULT: *const c_char = b"never-default\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_ROUTES: *const c_char = b"routes\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_CONFIG_ROUTE_METRIC: *const c_char = b"route-metric\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_ENCAPSULATION_LIMIT: *const c_char = b"encapsulation-limit\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_FLOW_LABEL: *const c_char = b"flow-label\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_INPUT_KEY: *const c_char = b"input-key\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_LOCAL: *const c_char = b"local\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_OUTPUT_KEY: *const c_char = b"output-key\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_PATH_MTU_DISCOVERY: *const c_char = b"path-mtu-discovery\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_REMOTE: *const c_char = b"remote\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_SETTING_NAME: *const c_char = b"ip-tunnel\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_TOS: *const c_char = b"tos\0" as *const u8 as *const c_char;
pub const NM_SETTING_IP_TUNNEL_TTL: *const c_char = b"ttl\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_ENCRYPT: *const c_char = b"encrypt\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_MKA_CAK: *const c_char = b"mka-cak\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_MKA_CAK_FLAGS: *const c_char = b"mka-cak-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_MKA_CAK_LENGTH: c_int = 32;
pub const NM_SETTING_MACSEC_MKA_CKN: *const c_char = b"mka-ckn\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_MKA_CKN_LENGTH: c_int = 64;
pub const NM_SETTING_MACSEC_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_PORT: *const c_char = b"port\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_SETTING_NAME: *const c_char = b"macsec\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACSEC_VALIDATION: *const c_char = b"validation\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACVLAN_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACVLAN_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACVLAN_PROMISCUOUS: *const c_char = b"promiscuous\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACVLAN_SETTING_NAME: *const c_char = b"macvlan\0" as *const u8 as *const c_char;
pub const NM_SETTING_MACVLAN_TAP: *const c_char = b"tap\0" as *const u8 as *const c_char;
pub const NM_SETTING_NAME: *const c_char = b"name\0" as *const u8 as *const c_char;
pub const NM_SETTING_OLPC_MESH_CHANNEL: *const c_char = b"channel\0" as *const u8 as *const c_char;
pub const NM_SETTING_OLPC_MESH_DHCP_ANYCAST_ADDRESS: *const c_char = b"dhcp-anycast-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_OLPC_MESH_SETTING_NAME: *const c_char = b"802-11-olpc-mesh\0" as *const u8 as *const c_char;
pub const NM_SETTING_OLPC_MESH_SSID: *const c_char = b"ssid\0" as *const u8 as *const c_char;
pub const NM_SETTING_PARAM_FUZZY_IGNORE: c_int = 8;
pub const NM_SETTING_PARAM_REQUIRED: c_int = 2;
pub const NM_SETTING_PARAM_SECRET: c_int = 4;
pub const NM_SETTING_PPPOE_PASSWORD: *const c_char = b"password\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPPOE_PASSWORD_FLAGS: *const c_char = b"password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPPOE_SERVICE: *const c_char = b"service\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPPOE_SETTING_NAME: *const c_char = b"pppoe\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPPOE_USERNAME: *const c_char = b"username\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_BAUD: *const c_char = b"baud\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_CRTSCTS: *const c_char = b"crtscts\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_LCP_ECHO_FAILURE: *const c_char = b"lcp-echo-failure\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_LCP_ECHO_INTERVAL: *const c_char = b"lcp-echo-interval\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_MPPE_STATEFUL: *const c_char = b"mppe-stateful\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_MRU: *const c_char = b"mru\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_NOAUTH: *const c_char = b"noauth\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_NOBSDCOMP: *const c_char = b"nobsdcomp\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_NODEFLATE: *const c_char = b"nodeflate\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_NO_VJ_COMP: *const c_char = b"no-vj-comp\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_REFUSE_CHAP: *const c_char = b"refuse-chap\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_REFUSE_EAP: *const c_char = b"refuse-eap\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_REFUSE_MSCHAP: *const c_char = b"refuse-mschap\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_REFUSE_MSCHAPV2: *const c_char = b"refuse-mschapv2\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_REFUSE_PAP: *const c_char = b"refuse-pap\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_REQUIRE_MPPE: *const c_char = b"require-mppe\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_REQUIRE_MPPE_128: *const c_char = b"require-mppe-128\0" as *const u8 as *const c_char;
pub const NM_SETTING_PPP_SETTING_NAME: *const c_char = b"ppp\0" as *const u8 as *const c_char;
pub const NM_SETTING_PROXY_BROWSER_ONLY: *const c_char = b"browser-only\0" as *const u8 as *const c_char;
pub const NM_SETTING_PROXY_METHOD: *const c_char = b"method\0" as *const u8 as *const c_char;
pub const NM_SETTING_PROXY_PAC_SCRIPT: *const c_char = b"pac-script\0" as *const u8 as *const c_char;
pub const NM_SETTING_PROXY_PAC_URL: *const c_char = b"pac-url\0" as *const u8 as *const c_char;
pub const NM_SETTING_PROXY_SETTING_NAME: *const c_char = b"proxy\0" as *const u8 as *const c_char;
pub const NM_SETTING_SERIAL_BAUD: *const c_char = b"baud\0" as *const u8 as *const c_char;
pub const NM_SETTING_SERIAL_BITS: *const c_char = b"bits\0" as *const u8 as *const c_char;
pub const NM_SETTING_SERIAL_PARITY: *const c_char = b"parity\0" as *const u8 as *const c_char;
pub const NM_SETTING_SERIAL_SEND_DELAY: *const c_char = b"send-delay\0" as *const u8 as *const c_char;
pub const NM_SETTING_SERIAL_SETTING_NAME: *const c_char = b"serial\0" as *const u8 as *const c_char;
pub const NM_SETTING_SERIAL_STOPBITS: *const c_char = b"stopbits\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_CONFIG: *const c_char = b"config\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_PORT_CONFIG: *const c_char = b"config\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_PORT_SETTING_NAME: *const c_char = b"team-port\0" as *const u8 as *const c_char;
pub const NM_SETTING_TEAM_SETTING_NAME: *const c_char = b"team\0" as *const u8 as *const c_char;
pub const NM_SETTING_TUN_GROUP: *const c_char = b"group\0" as *const u8 as *const c_char;
pub const NM_SETTING_TUN_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_TUN_MULTI_QUEUE: *const c_char = b"multi-queue\0" as *const u8 as *const c_char;
pub const NM_SETTING_TUN_OWNER: *const c_char = b"owner\0" as *const u8 as *const c_char;
pub const NM_SETTING_TUN_PI: *const c_char = b"pi\0" as *const u8 as *const c_char;
pub const NM_SETTING_TUN_SETTING_NAME: *const c_char = b"tun\0" as *const u8 as *const c_char;
pub const NM_SETTING_TUN_VNET_HDR: *const c_char = b"vnet-hdr\0" as *const u8 as *const c_char;
pub const NM_SETTING_USER_DATA: *const c_char = b"data\0" as *const u8 as *const c_char;
pub const NM_SETTING_USER_SETTING_NAME: *const c_char = b"user\0" as *const u8 as *const c_char;
pub const NM_SETTING_VLAN_EGRESS_PRIORITY_MAP: *const c_char = b"egress-priority-map\0" as *const u8 as *const c_char;
pub const NM_SETTING_VLAN_FLAGS: *const c_char = b"flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_VLAN_ID: *const c_char = b"id\0" as *const u8 as *const c_char;
pub const NM_SETTING_VLAN_INGRESS_PRIORITY_MAP: *const c_char = b"ingress-priority-map\0" as *const u8 as *const c_char;
pub const NM_SETTING_VLAN_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_SETTING_VLAN_SETTING_NAME: *const c_char = b"vlan\0" as *const u8 as *const c_char;
pub const NM_SETTING_VPN_DATA: *const c_char = b"data\0" as *const u8 as *const c_char;
pub const NM_SETTING_VPN_PERSISTENT: *const c_char = b"persistent\0" as *const u8 as *const c_char;
pub const NM_SETTING_VPN_SECRETS: *const c_char = b"secrets\0" as *const u8 as *const c_char;
pub const NM_SETTING_VPN_SERVICE_TYPE: *const c_char = b"service-type\0" as *const u8 as *const c_char;
pub const NM_SETTING_VPN_SETTING_NAME: *const c_char = b"vpn\0" as *const u8 as *const c_char;
pub const NM_SETTING_VPN_TIMEOUT: *const c_char = b"timeout\0" as *const u8 as *const c_char;
pub const NM_SETTING_VPN_USER_NAME: *const c_char = b"user-name\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_AGEING: *const c_char = b"ageing\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_DESTINATION_PORT: *const c_char = b"destination-port\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_ID: *const c_char = b"id\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_L2_MISS: *const c_char = b"l2-miss\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_L3_MISS: *const c_char = b"l3-miss\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_LEARNING: *const c_char = b"learning\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_LIMIT: *const c_char = b"limit\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_LOCAL: *const c_char = b"local\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_PARENT: *const c_char = b"parent\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_PROXY: *const c_char = b"proxy\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_REMOTE: *const c_char = b"remote\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_RSC: *const c_char = b"rsc\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_SETTING_NAME: *const c_char = b"vxlan\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_SOURCE_PORT_MAX: *const c_char = b"source-port-max\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_SOURCE_PORT_MIN: *const c_char = b"source-port-min\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_TOS: *const c_char = b"tos\0" as *const u8 as *const c_char;
pub const NM_SETTING_VXLAN_TTL: *const c_char = b"ttl\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIMAX_MAC_ADDRESS: *const c_char = b"mac-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIMAX_NETWORK_NAME: *const c_char = b"network-name\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIMAX_SETTING_NAME: *const c_char = b"wimax\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_AUTO_NEGOTIATE: *const c_char = b"auto-negotiate\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_CLONED_MAC_ADDRESS: *const c_char = b"cloned-mac-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_DUPLEX: *const c_char = b"duplex\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_GENERATE_MAC_ADDRESS_MASK: *const c_char = b"generate-mac-address-mask\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_MAC_ADDRESS: *const c_char = b"mac-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_MAC_ADDRESS_BLACKLIST: *const c_char = b"mac-address-blacklist\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_PORT: *const c_char = b"port\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_S390_NETTYPE: *const c_char = b"s390-nettype\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_S390_OPTIONS: *const c_char = b"s390-options\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_S390_SUBCHANNELS: *const c_char = b"s390-subchannels\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_SETTING_NAME: *const c_char = b"802-3-ethernet\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_SPEED: *const c_char = b"speed\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_WAKE_ON_LAN: *const c_char = b"wake-on-lan\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_PASSWORD: *const c_char = b"wake-on-lan-password\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_BAND: *const c_char = b"band\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_BSSID: *const c_char = b"bssid\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_CHANNEL: *const c_char = b"channel\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_CLONED_MAC_ADDRESS: *const c_char = b"cloned-mac-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_GENERATE_MAC_ADDRESS_MASK: *const c_char = b"generate-mac-address-mask\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_HIDDEN: *const c_char = b"hidden\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MAC_ADDRESS: *const c_char = b"mac-address\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MAC_ADDRESS_BLACKLIST: *const c_char = b"mac-address-blacklist\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MAC_ADDRESS_RANDOMIZATION: *const c_char = b"mac-address-randomization\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MODE: *const c_char = b"mode\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MODE_ADHOC: *const c_char = b"adhoc\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MODE_AP: *const c_char = b"ap\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MODE_INFRA: *const c_char = b"infrastructure\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_POWERSAVE: *const c_char = b"powersave\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_RATE: *const c_char = b"rate\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_AUTH_ALG: *const c_char = b"auth-alg\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_GROUP: *const c_char = b"group\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_KEY_MGMT: *const c_char = b"key-mgmt\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD: *const c_char = b"leap-password\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_LEAP_PASSWORD_FLAGS: *const c_char = b"leap-password-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_LEAP_USERNAME: *const c_char = b"leap-username\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_PAIRWISE: *const c_char = b"pairwise\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_PROTO: *const c_char = b"proto\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_PSK: *const c_char = b"psk\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_PSK_FLAGS: *const c_char = b"psk-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_SETTING_NAME: *const c_char = b"802-11-wireless-security\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY0: *const c_char = b"wep-key0\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY1: *const c_char = b"wep-key1\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY2: *const c_char = b"wep-key2\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY3: *const c_char = b"wep-key3\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY_FLAGS: *const c_char = b"wep-key-flags\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_WEP_KEY_TYPE: *const c_char = b"wep-key-type\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SECURITY_WEP_TX_KEYIDX: *const c_char = b"wep-tx-keyidx\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SEEN_BSSIDS: *const c_char = b"seen-bssids\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SETTING_NAME: *const c_char = b"802-11-wireless\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_SSID: *const c_char = b"ssid\0" as *const u8 as *const c_char;
pub const NM_SETTING_WIRELESS_TX_POWER: *const c_char = b"tx-power\0" as *const u8 as *const c_char;
pub const NM_UTILS_HWADDR_LEN_MAX: c_int = 20;
pub const NM_VLAN_FLAGS_ALL: c_int = 0;
pub const NM_VPN_CONNECTION_BANNER: *const c_char = b"banner\0" as *const u8 as *const c_char;
pub const NM_VPN_CONNECTION_VPN_STATE: *const c_char = b"vpn-state\0" as *const u8 as *const c_char;
pub const NM_VPN_DBUS_PLUGIN_INTERFACE: *const c_char = b"org.freedesktop.NetworkManager.VPN.Plugin\0" as *const u8 as *const c_char;
pub const NM_VPN_DBUS_PLUGIN_PATH: *const c_char = b"/org/freedesktop/NetworkManager/VPN/Plugin\0" as *const u8 as *const c_char;
pub const NM_VPN_EDITOR_PLUGIN_DESCRIPTION: *const c_char = b"description\0" as *const u8 as *const c_char;
pub const NM_VPN_EDITOR_PLUGIN_NAME: *const c_char = b"name\0" as *const u8 as *const c_char;
pub const NM_VPN_EDITOR_PLUGIN_SERVICE: *const c_char = b"service\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_CAN_PERSIST: *const c_char = b"can-persist\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_CONFIG_BANNER: *const c_char = b"banner\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_CONFIG_EXT_GATEWAY: *const c_char = b"gateway\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_CONFIG_HAS_IP4: *const c_char = b"has-ip4\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_CONFIG_HAS_IP6: *const c_char = b"has-ip6\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_CONFIG_MTU: *const c_char = b"mtu\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_CONFIG_PROXY_PAC: *const c_char = b"pac\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_CONFIG_TUNDEV: *const c_char = b"tundev\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_INFO_FILENAME: *const c_char = b"filename\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_INFO_KEYFILE: *const c_char = b"keyfile\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_INFO_KF_GROUP_CONNECTION: *const c_char = b"VPN Connection\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_INFO_KF_GROUP_GNOME: *const c_char = b"GNOME\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_INFO_KF_GROUP_LIBNM: *const c_char = b"libnm\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_INFO_NAME: *const c_char = b"name\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_ADDRESS: *const c_char = b"address\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_DNS: *const c_char = b"dns\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_DOMAIN: *const c_char = b"domain\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_DOMAINS: *const c_char = b"domains\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_INT_GATEWAY: *const c_char = b"internal-gateway\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_MSS: *const c_char = b"mss\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_NBNS: *const c_char = b"nbns\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_NEVER_DEFAULT: *const c_char = b"never-default\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_PREFIX: *const c_char = b"prefix\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_PRESERVE_ROUTES: *const c_char = b"preserve-routes\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_PTP: *const c_char = b"ptp\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP4_CONFIG_ROUTES: *const c_char = b"routes\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_ADDRESS: *const c_char = b"address\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_DNS: *const c_char = b"dns\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_DOMAIN: *const c_char = b"domain\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_DOMAINS: *const c_char = b"domains\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_INT_GATEWAY: *const c_char = b"internal-gateway\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_MSS: *const c_char = b"mss\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_NEVER_DEFAULT: *const c_char = b"never-default\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_PREFIX: *const c_char = b"prefix\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_PRESERVE_ROUTES: *const c_char = b"preserve-routes\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_PTP: *const c_char = b"ptp\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_IP6_CONFIG_ROUTES: *const c_char = b"routes\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_OLD_DBUS_SERVICE_NAME: *const c_char = b"service-name\0" as *const u8 as *const c_char;
pub const NM_VPN_PLUGIN_OLD_STATE: *const c_char = b"state\0" as *const u8 as *const c_char;
pub const NM_VPN_SERVICE_PLUGIN_DBUS_SERVICE_NAME: *const c_char = b"service-name\0" as *const u8 as *const c_char;
pub const NM_VPN_SERVICE_PLUGIN_DBUS_WATCH_PEER: *const c_char = b"watch-peer\0" as *const u8 as *const c_char;
pub const NM_VPN_SERVICE_PLUGIN_STATE: *const c_char = b"state\0" as *const u8 as *const c_char;
pub const NM_WIMAX_NSP_NAME: *const c_char = b"name\0" as *const u8 as *const c_char;
pub const NM_WIMAX_NSP_NETWORK_TYPE: *const c_char = b"network-type\0" as *const u8 as *const c_char;
pub const NM_WIMAX_NSP_SIGNAL_QUALITY: *const c_char = b"signal-quality\0" as *const u8 as *const c_char;

// Flags
pub type NM80211ApFlags = c_uint;
pub const NM_802_11_AP_FLAGS_NONE: NM80211ApFlags = 0;
pub const NM_802_11_AP_FLAGS_PRIVACY: NM80211ApFlags = 1;

pub type NM80211ApSecurityFlags = c_uint;
pub const NM_802_11_AP_SEC_NONE: NM80211ApSecurityFlags = 0;
pub const NM_802_11_AP_SEC_PAIR_WEP40: NM80211ApSecurityFlags = 1;
pub const NM_802_11_AP_SEC_PAIR_WEP104: NM80211ApSecurityFlags = 2;
pub const NM_802_11_AP_SEC_PAIR_TKIP: NM80211ApSecurityFlags = 4;
pub const NM_802_11_AP_SEC_PAIR_CCMP: NM80211ApSecurityFlags = 8;
pub const NM_802_11_AP_SEC_GROUP_WEP40: NM80211ApSecurityFlags = 16;
pub const NM_802_11_AP_SEC_GROUP_WEP104: NM80211ApSecurityFlags = 32;
pub const NM_802_11_AP_SEC_GROUP_TKIP: NM80211ApSecurityFlags = 64;
pub const NM_802_11_AP_SEC_GROUP_CCMP: NM80211ApSecurityFlags = 128;
pub const NM_802_11_AP_SEC_KEY_MGMT_PSK: NM80211ApSecurityFlags = 256;
pub const NM_802_11_AP_SEC_KEY_MGMT_802_1X: NM80211ApSecurityFlags = 512;

pub type NMBluetoothCapabilities = c_uint;
pub const NM_BT_CAPABILITY_NONE: NMBluetoothCapabilities = 0;
pub const NM_BT_CAPABILITY_DUN: NMBluetoothCapabilities = 1;
pub const NM_BT_CAPABILITY_NAP: NMBluetoothCapabilities = 2;

pub type NMConnectionSerializationFlags = c_uint;
pub const NM_CONNECTION_SERIALIZE_ALL: NMConnectionSerializationFlags = 0;
pub const NM_CONNECTION_SERIALIZE_NO_SECRETS: NMConnectionSerializationFlags = 1;
pub const NM_CONNECTION_SERIALIZE_ONLY_SECRETS: NMConnectionSerializationFlags = 2;

pub type NMDeviceCapabilities = c_uint;
pub const NM_DEVICE_CAP_NONE: NMDeviceCapabilities = 0;
pub const NM_DEVICE_CAP_NM_SUPPORTED: NMDeviceCapabilities = 1;
pub const NM_DEVICE_CAP_CARRIER_DETECT: NMDeviceCapabilities = 2;
pub const NM_DEVICE_CAP_IS_SOFTWARE: NMDeviceCapabilities = 4;
pub const NM_DEVICE_CAP_SRIOV: NMDeviceCapabilities = 8;

pub type NMDeviceModemCapabilities = c_uint;
pub const NM_DEVICE_MODEM_CAPABILITY_NONE: NMDeviceModemCapabilities = 0;
pub const NM_DEVICE_MODEM_CAPABILITY_POTS: NMDeviceModemCapabilities = 1;
pub const NM_DEVICE_MODEM_CAPABILITY_CDMA_EVDO: NMDeviceModemCapabilities = 2;
pub const NM_DEVICE_MODEM_CAPABILITY_GSM_UMTS: NMDeviceModemCapabilities = 4;
pub const NM_DEVICE_MODEM_CAPABILITY_LTE: NMDeviceModemCapabilities = 8;

pub type NMDeviceWifiCapabilities = c_uint;
pub const NM_WIFI_DEVICE_CAP_NONE: NMDeviceWifiCapabilities = 0;
pub const NM_WIFI_DEVICE_CAP_CIPHER_WEP40: NMDeviceWifiCapabilities = 1;
pub const NM_WIFI_DEVICE_CAP_CIPHER_WEP104: NMDeviceWifiCapabilities = 2;
pub const NM_WIFI_DEVICE_CAP_CIPHER_TKIP: NMDeviceWifiCapabilities = 4;
pub const NM_WIFI_DEVICE_CAP_CIPHER_CCMP: NMDeviceWifiCapabilities = 8;
pub const NM_WIFI_DEVICE_CAP_WPA: NMDeviceWifiCapabilities = 16;
pub const NM_WIFI_DEVICE_CAP_RSN: NMDeviceWifiCapabilities = 32;
pub const NM_WIFI_DEVICE_CAP_AP: NMDeviceWifiCapabilities = 64;
pub const NM_WIFI_DEVICE_CAP_ADHOC: NMDeviceWifiCapabilities = 128;
pub const NM_WIFI_DEVICE_CAP_FREQ_VALID: NMDeviceWifiCapabilities = 256;
pub const NM_WIFI_DEVICE_CAP_FREQ_2GHZ: NMDeviceWifiCapabilities = 512;
pub const NM_WIFI_DEVICE_CAP_FREQ_5GHZ: NMDeviceWifiCapabilities = 1024;

pub type NMSecretAgentCapabilities = c_uint;
pub const NM_SECRET_AGENT_CAPABILITY_NONE: NMSecretAgentCapabilities = 0;
pub const NM_SECRET_AGENT_CAPABILITY_VPN_HINTS: NMSecretAgentCapabilities = 1;
pub const NM_SECRET_AGENT_CAPABILITY_LAST: NMSecretAgentCapabilities = 1;

pub type NMSecretAgentGetSecretsFlags = c_uint;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_NONE: NMSecretAgentGetSecretsFlags = 0;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_ALLOW_INTERACTION: NMSecretAgentGetSecretsFlags = 1;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_REQUEST_NEW: NMSecretAgentGetSecretsFlags = 2;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_USER_REQUESTED: NMSecretAgentGetSecretsFlags = 4;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_ONLY_SYSTEM: NMSecretAgentGetSecretsFlags = 2147483648;
pub const NM_SECRET_AGENT_GET_SECRETS_FLAG_NO_ERRORS: NMSecretAgentGetSecretsFlags = 1073741824;

pub type NMSetting8021xAuthFlags = c_uint;
pub const NM_SETTING_802_1X_AUTH_FLAGS_NONE: NMSetting8021xAuthFlags = 0;
pub const NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_0_DISABLE: NMSetting8021xAuthFlags = 1;
pub const NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_1_DISABLE: NMSetting8021xAuthFlags = 2;
pub const NM_SETTING_802_1X_AUTH_FLAGS_TLS_1_2_DISABLE: NMSetting8021xAuthFlags = 4;
pub const NM_SETTING_802_1X_AUTH_FLAGS_ALL: NMSetting8021xAuthFlags = 7;

pub type NMSettingDcbFlags = c_uint;
pub const NM_SETTING_DCB_FLAG_NONE: NMSettingDcbFlags = 0;
pub const NM_SETTING_DCB_FLAG_ENABLE: NMSettingDcbFlags = 1;
pub const NM_SETTING_DCB_FLAG_ADVERTISE: NMSettingDcbFlags = 2;
pub const NM_SETTING_DCB_FLAG_WILLING: NMSettingDcbFlags = 4;

pub type NMSettingSecretFlags = c_uint;
pub const NM_SETTING_SECRET_FLAG_NONE: NMSettingSecretFlags = 0;
pub const NM_SETTING_SECRET_FLAG_AGENT_OWNED: NMSettingSecretFlags = 1;
pub const NM_SETTING_SECRET_FLAG_NOT_SAVED: NMSettingSecretFlags = 2;
pub const NM_SETTING_SECRET_FLAG_NOT_REQUIRED: NMSettingSecretFlags = 4;

pub type NMSettingWiredWakeOnLan = c_uint;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_PHY: NMSettingWiredWakeOnLan = 2;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_UNICAST: NMSettingWiredWakeOnLan = 4;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_MULTICAST: NMSettingWiredWakeOnLan = 8;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_BROADCAST: NMSettingWiredWakeOnLan = 16;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_ARP: NMSettingWiredWakeOnLan = 32;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_MAGIC: NMSettingWiredWakeOnLan = 64;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_DEFAULT: NMSettingWiredWakeOnLan = 1;
pub const NM_SETTING_WIRED_WAKE_ON_LAN_IGNORE: NMSettingWiredWakeOnLan = 32768;

pub type NMVlanFlags = c_uint;
pub const NM_VLAN_FLAG_REORDER_HEADERS: NMVlanFlags = 1;
pub const NM_VLAN_FLAG_GVRP: NMVlanFlags = 2;
pub const NM_VLAN_FLAG_LOOSE_BINDING: NMVlanFlags = 4;
pub const NM_VLAN_FLAG_MVRP: NMVlanFlags = 8;

pub type NMVpnEditorPluginCapability = c_uint;
pub const NM_VPN_EDITOR_PLUGIN_CAPABILITY_NONE: NMVpnEditorPluginCapability = 0;
pub const NM_VPN_EDITOR_PLUGIN_CAPABILITY_IMPORT: NMVpnEditorPluginCapability = 1;
pub const NM_VPN_EDITOR_PLUGIN_CAPABILITY_EXPORT: NMVpnEditorPluginCapability = 2;
pub const NM_VPN_EDITOR_PLUGIN_CAPABILITY_IPV6: NMVpnEditorPluginCapability = 4;

// Callbacks
pub type NMSecretAgentOldDeleteSecretsFunc = Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *mut NMConnection, *mut glib::GError, gpointer)>;
pub type NMSecretAgentOldGetSecretsFunc = Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *mut NMConnection, *mut glib::GVariant, *mut glib::GError, gpointer)>;
pub type NMSecretAgentOldSaveSecretsFunc = Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *mut NMConnection, *mut glib::GError, gpointer)>;
pub type NMSettingClearSecretsWithFlagsFn = Option<unsafe extern "C" fn(*mut NMSetting, *const c_char, NMSettingSecretFlags, gpointer) -> gboolean>;
pub type NMSettingValueIterFn = Option<unsafe extern "C" fn(*mut NMSetting, *const c_char, *const gobject::GValue, gobject::GParamFlags, gpointer)>;
pub type NMUtilsCheckFilePredicate = Option<unsafe extern "C" fn(*const c_char, *const stat, gpointer, *mut *mut glib::GError) -> gboolean>;
pub type NMUtilsFileSearchInPathsPredicate = Option<unsafe extern "C" fn(*const c_char, gpointer) -> gboolean>;
pub type NMVpnIterFunc = Option<unsafe extern "C" fn(*const c_char, *const c_char, gpointer)>;

// Records
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMAccessPointClass {
    pub parent: NMObjectClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMAccessPointClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMAccessPointClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMActiveConnectionClass {
    pub parent: NMObjectClass,
    pub padding: [gpointer; 8],
}

impl ::std::fmt::Debug for NMActiveConnectionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMActiveConnectionClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMClientClass {
    pub parent: gobject::GObjectClass,
    pub device_added: Option<unsafe extern "C" fn(*mut NMClient, *mut NMDevice)>,
    pub device_removed: Option<unsafe extern "C" fn(*mut NMClient, *mut NMDevice)>,
    pub any_device_added: Option<unsafe extern "C" fn(*mut NMClient, *mut NMDevice)>,
    pub any_device_removed: Option<unsafe extern "C" fn(*mut NMClient, *mut NMDevice)>,
    pub permission_changed: Option<unsafe extern "C" fn(*mut NMClient, NMClientPermission, NMClientPermissionResult)>,
    pub connection_added: Option<unsafe extern "C" fn(*mut NMClient, *mut NMRemoteConnection)>,
    pub connection_removed: Option<unsafe extern "C" fn(*mut NMClient, *mut NMRemoteConnection)>,
    pub padding: [gpointer; 6],
}

impl ::std::fmt::Debug for NMClientClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMClientClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("device_added", &self.device_added)
         .field("device_removed", &self.device_removed)
         .field("any_device_added", &self.any_device_added)
         .field("any_device_removed", &self.any_device_removed)
         .field("permission_changed", &self.permission_changed)
         .field("connection_added", &self.connection_added)
         .field("connection_removed", &self.connection_removed)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMConnectionInterface {
    pub parent: gobject::GTypeInterface,
    pub secrets_updated: Option<unsafe extern "C" fn(*mut NMConnection, *const c_char)>,
    pub secrets_cleared: Option<unsafe extern "C" fn(*mut NMConnection)>,
    pub changed: Option<unsafe extern "C" fn(*mut NMConnection)>,
}

impl ::std::fmt::Debug for NMConnectionInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMConnectionInterface @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("secrets_updated", &self.secrets_updated)
         .field("secrets_cleared", &self.secrets_cleared)
         .field("changed", &self.changed)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceAdslClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceAdslClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceAdslClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceBondClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceBondClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceBondClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceBridgeClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceBridgeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceBridgeClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceBtClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceBtClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceBtClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceClass {
    pub parent: NMObjectClass,
    pub state_changed: Option<unsafe extern "C" fn(*mut NMDevice, NMDeviceState, NMDeviceState, NMDeviceStateReason)>,
    pub connection_compatible: Option<unsafe extern "C" fn(*mut NMDevice, *mut NMConnection, *mut *mut glib::GError) -> gboolean>,
    pub get_type_description: Option<unsafe extern "C" fn(*mut NMDevice) -> *const c_char>,
    pub get_hw_address: Option<unsafe extern "C" fn(*mut NMDevice) -> *const c_char>,
    pub get_setting_type: Option<unsafe extern "C" fn(*mut NMDevice) -> GType>,
    pub padding: [gpointer; 8],
}

impl ::std::fmt::Debug for NMDeviceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("state_changed", &self.state_changed)
         .field("connection_compatible", &self.connection_compatible)
         .field("get_type_description", &self.get_type_description)
         .field("get_hw_address", &self.get_hw_address)
         .field("get_setting_type", &self.get_setting_type)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceDummyClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceDummyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceDummyClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceEthernetClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceEthernetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceEthernetClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceGenericClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceGenericClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceGenericClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceIPTunnelClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceIPTunnelClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceIPTunnelClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceInfinibandClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceInfinibandClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceInfinibandClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceMacsecClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceMacsecClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceMacsecClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceMacvlanClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceMacvlanClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceMacvlanClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceModemClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceModemClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceModemClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceOlpcMeshClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceOlpcMeshClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceOlpcMeshClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceTeamClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceTeamClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceTeamClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceTunClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceTunClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceTunClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceVlanClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceVlanClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceVlanClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceVxlanClass {
    pub parent: NMDeviceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceVxlanClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceVxlanClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceWifiClass {
    pub parent: NMDeviceClass,
    pub access_point_added: Option<unsafe extern "C" fn(*mut NMDeviceWifi, *mut NMAccessPoint)>,
    pub access_point_removed: Option<unsafe extern "C" fn(*mut NMDeviceWifi, *mut NMAccessPoint)>,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceWifiClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceWifiClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("access_point_added", &self.access_point_added)
         .field("access_point_removed", &self.access_point_removed)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceWimaxClass {
    pub parent: NMDeviceClass,
    pub nsp_added: Option<unsafe extern "C" fn(*mut NMDeviceWimax, *mut NMWimaxNsp)>,
    pub nsp_removed: Option<unsafe extern "C" fn(*mut NMDeviceWimax, *mut NMWimaxNsp)>,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMDeviceWimaxClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceWimaxClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("nsp_added", &self.nsp_added)
         .field("nsp_removed", &self.nsp_removed)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDhcpConfigClass {
    pub parent: NMObjectClass,
    pub padding: [gpointer; 8],
}

impl ::std::fmt::Debug for NMDhcpConfigClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDhcpConfigClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
pub struct NMDnsEntry(c_void);

impl ::std::fmt::Debug for NMDnsEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDnsEntry @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMIPAddress(c_void);

impl ::std::fmt::Debug for NMIPAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMIPAddress @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMIPConfigClass {
    pub parent: NMObjectClass,
    pub padding: [gpointer; 8],
}

impl ::std::fmt::Debug for NMIPConfigClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMIPConfigClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
pub struct NMIPRoute(c_void);

impl ::std::fmt::Debug for NMIPRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMIPRoute @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
pub struct NMLldpNeighbor(c_void);

impl ::std::fmt::Debug for NMLldpNeighbor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMLldpNeighbor @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMObjectClass {
    pub parent: gobject::GObjectClass,
    pub init_dbus: Option<unsafe extern "C" fn(*mut NMObject)>,
    pub object_creation_failed: Option<unsafe extern "C" fn(*mut NMObject, *const c_char)>,
    pub padding: [gpointer; 8],
}

impl ::std::fmt::Debug for NMObjectClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMObjectClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("init_dbus", &self.init_dbus)
         .field("object_creation_failed", &self.object_creation_failed)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMRemoteConnectionClass {
    pub parent_class: NMObjectClass,
    pub padding: [gpointer; 8],
}

impl ::std::fmt::Debug for NMRemoteConnectionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMRemoteConnectionClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSecretAgentOldClass {
    pub parent: gobject::GObjectClass,
    pub get_secrets: Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *mut NMConnection, *const c_char, *const c_char, *mut *mut c_char, NMSecretAgentGetSecretsFlags, NMSecretAgentOldGetSecretsFunc, gpointer)>,
    pub cancel_get_secrets: Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *const c_char, *const c_char)>,
    pub save_secrets: Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *mut NMConnection, *const c_char, NMSecretAgentOldSaveSecretsFunc, gpointer)>,
    pub delete_secrets: Option<unsafe extern "C" fn(*mut NMSecretAgentOld, *mut NMConnection, *const c_char, NMSecretAgentOldDeleteSecretsFunc, gpointer)>,
    pub padding: [gpointer; 8],
}

impl ::std::fmt::Debug for NMSecretAgentOldClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSecretAgentOldClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("get_secrets", &self.get_secrets)
         .field("cancel_get_secrets", &self.cancel_get_secrets)
         .field("save_secrets", &self.save_secrets)
         .field("delete_secrets", &self.delete_secrets)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSetting8021xClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSetting8021xClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSetting8021xClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingAdslClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingAdslClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingAdslClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingBluetoothClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingBluetoothClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBluetoothClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingBondClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingBondClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBondClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingBridgeClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingBridgeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBridgeClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingBridgePortClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingBridgePortClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBridgePortClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingCdmaClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingCdmaClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingCdmaClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingClass {
    pub parent: gobject::GObjectClass,
    pub verify: Option<unsafe extern "C" fn(*mut NMSetting, *mut NMConnection, *mut *mut glib::GError) -> c_int>,
    pub verify_secrets: Option<unsafe extern "C" fn(*mut NMSetting, *mut NMConnection, *mut *mut glib::GError) -> gboolean>,
    pub need_secrets: Option<unsafe extern "C" fn(*mut NMSetting) -> *mut glib::GPtrArray>,
    pub update_one_secret: Option<unsafe extern "C" fn(*mut NMSetting, *const c_char, *mut glib::GVariant, *mut *mut glib::GError) -> c_int>,
    pub get_secret_flags: Option<unsafe extern "C" fn(*mut NMSetting, *const c_char, gboolean, NMSettingSecretFlags, *mut *mut glib::GError) -> gboolean>,
    pub set_secret_flags: Option<unsafe extern "C" fn(*mut NMSetting, *const c_char, gboolean, NMSettingSecretFlags, *mut *mut glib::GError) -> gboolean>,
    pub clear_secrets_with_flags: Option<unsafe extern "C" fn(*mut NMSetting, *mut gobject::GParamSpec, NMSettingClearSecretsWithFlagsFn, gpointer) -> gboolean>,
    pub compare_property: Option<unsafe extern "C" fn(*mut NMSetting, *mut NMSetting, *const gobject::GParamSpec, NMSettingCompareFlags) -> gboolean>,
    pub padding: [gpointer; 7],
}

impl ::std::fmt::Debug for NMSettingClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("verify", &self.verify)
         .field("verify_secrets", &self.verify_secrets)
         .field("need_secrets", &self.need_secrets)
         .field("update_one_secret", &self.update_one_secret)
         .field("get_secret_flags", &self.get_secret_flags)
         .field("set_secret_flags", &self.set_secret_flags)
         .field("clear_secrets_with_flags", &self.clear_secrets_with_flags)
         .field("compare_property", &self.compare_property)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingConnectionClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingConnectionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingConnectionClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingDcbClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingDcbClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingDcbClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingDummyClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingDummyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingDummyClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingGenericClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingGenericClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingGenericClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingGsmClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingGsmClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingGsmClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingIP4ConfigClass {
    pub parent: NMSettingIPConfigClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingIP4ConfigClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIP4ConfigClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingIP6ConfigClass {
    pub parent: NMSettingIPConfigClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingIP6ConfigClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIP6ConfigClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingIPConfigClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 8],
}

impl ::std::fmt::Debug for NMSettingIPConfigClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIPConfigClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("padding", &self.padding)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingIPTunnelClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingIPTunnelClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIPTunnelClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingInfinibandClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingInfinibandClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingInfinibandClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingMacsecClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingMacsecClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingMacsecClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingMacvlanClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingMacvlanClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingMacvlanClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingOlpcMeshClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingOlpcMeshClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOlpcMeshClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingPppClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingPppClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingPppClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingPppoeClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingPppoeClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingPppoeClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingProxyClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingProxyClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingProxyClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("padding", &self.padding)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingSerialClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingSerialClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingSerialClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingTeamClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingTeamClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTeamClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingTeamPortClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingTeamPortClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTeamPortClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingTunClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingTunClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTunClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingUserClass(c_void);

impl ::std::fmt::Debug for NMSettingUserClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingUserClass @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingVlanClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingVlanClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVlanClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingVpnClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingVpnClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVpnClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingVxlanClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingVxlanClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVxlanClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingWimaxClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingWimaxClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWimaxClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingWiredClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingWiredClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWiredClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingWirelessClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingWirelessClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWirelessClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingWirelessSecurityClass {
    pub parent: NMSettingClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSettingWirelessSecurityClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWirelessSecurityClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSimpleConnectionClass {
    pub parent_class: gobject::GObjectClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMSimpleConnectionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSimpleConnectionClass @ {:?}", self as *const _))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct NMVariantAttributeSpec(c_void);

impl ::std::fmt::Debug for NMVariantAttributeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVariantAttributeSpec @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMVpnConnectionClass {
    pub parent: NMActiveConnectionClass,
    pub vpn_state_changed: Option<unsafe extern "C" fn(*mut NMVpnConnection, NMVpnConnectionState, NMVpnConnectionStateReason)>,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMVpnConnectionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnConnectionClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("vpn_state_changed", &self.vpn_state_changed)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMVpnEditorInterface {
    pub g_iface: gobject::GTypeInterface,
    pub get_widget: Option<unsafe extern "C" fn(*mut NMVpnEditor) -> *mut gobject::GObject>,
    pub placeholder: Option<unsafe extern "C" fn()>,
    pub update_connection: Option<unsafe extern "C" fn(*mut NMVpnEditor, *mut NMConnection, *mut *mut glib::GError) -> gboolean>,
    pub changed: Option<unsafe extern "C" fn(*mut NMVpnEditor)>,
}

impl ::std::fmt::Debug for NMVpnEditorInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnEditorInterface @ {:?}", self as *const _))
         .field("g_iface", &self.g_iface)
         .field("get_widget", &self.get_widget)
         .field("placeholder", &self.placeholder)
         .field("update_connection", &self.update_connection)
         .field("changed", &self.changed)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMVpnEditorPluginInterface {
    pub g_iface: gobject::GTypeInterface,
    pub get_editor: Option<unsafe extern "C" fn(*mut NMVpnEditorPlugin, *mut NMConnection, *mut *mut glib::GError) -> *mut NMVpnEditor>,
    pub get_capabilities: Option<unsafe extern "C" fn(*mut NMVpnEditorPlugin) -> NMVpnEditorPluginCapability>,
    pub import_from_file: Option<unsafe extern "C" fn(*mut NMVpnEditorPlugin, *const c_char, *mut *mut glib::GError) -> *mut NMConnection>,
    pub export_to_file: Option<unsafe extern "C" fn(*mut NMVpnEditorPlugin, *const c_char, *mut NMConnection, *mut *mut glib::GError) -> gboolean>,
    pub get_suggested_filename: Option<unsafe extern "C" fn(*mut NMVpnEditorPlugin, *mut NMConnection) -> *mut c_char>,
    pub notify_plugin_info_set: Option<unsafe extern "C" fn(*mut NMVpnEditorPlugin, *mut _NMVpnPluginInfo)>,
    pub get_vt: Option<unsafe extern "C" fn(*mut NMVpnEditorPlugin, *mut size_t) -> *const NMVpnEditorPluginVT>,
}

impl ::std::fmt::Debug for NMVpnEditorPluginInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnEditorPluginInterface @ {:?}", self as *const _))
         .field("g_iface", &self.g_iface)
         .field("get_editor", &self.get_editor)
         .field("get_capabilities", &self.get_capabilities)
         .field("import_from_file", &self.import_from_file)
         .field("export_to_file", &self.export_to_file)
         .field("get_suggested_filename", &self.get_suggested_filename)
         .field("notify_plugin_info_set", &self.notify_plugin_info_set)
         .field("get_vt", &self.get_vt)
         .finish()
    }
}

#[repr(C)]
pub struct NMVpnEditorPluginVT(c_void);

impl ::std::fmt::Debug for NMVpnEditorPluginVT {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnEditorPluginVT @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMVpnPluginInfoClass {
    pub parent: gobject::GObjectClass,
    pub padding: [gpointer; 8],
}

impl ::std::fmt::Debug for NMVpnPluginInfoClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnPluginInfoClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMVpnPluginOldClass {
    pub parent: gobject::GObjectClass,
    pub state_changed: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, NMVpnServiceState)>,
    pub ip4_config: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *mut glib::GVariant)>,
    pub login_banner: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *const c_char)>,
    pub failure: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, NMVpnPluginFailure)>,
    pub quit: Option<unsafe extern "C" fn(*mut NMVpnPluginOld)>,
    pub config: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *mut glib::GVariant)>,
    pub ip6_config: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *mut glib::GVariant)>,
    pub connect: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *mut NMConnection, *mut *mut glib::GError) -> gboolean>,
    pub need_secrets: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *mut NMConnection, *mut *const c_char, *mut *mut glib::GError) -> gboolean>,
    pub disconnect: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *mut *mut glib::GError) -> gboolean>,
    pub new_secrets: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *mut NMConnection, *mut *mut glib::GError) -> gboolean>,
    pub connect_interactive: Option<unsafe extern "C" fn(*mut NMVpnPluginOld, *mut NMConnection, *mut glib::GVariant, *mut *mut glib::GError) -> gboolean>,
    pub padding: [gpointer; 8],
}

impl ::std::fmt::Debug for NMVpnPluginOldClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnPluginOldClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("state_changed", &self.state_changed)
         .field("ip4_config", &self.ip4_config)
         .field("login_banner", &self.login_banner)
         .field("failure", &self.failure)
         .field("quit", &self.quit)
         .field("config", &self.config)
         .field("ip6_config", &self.ip6_config)
         .field("connect", &self.connect)
         .field("need_secrets", &self.need_secrets)
         .field("disconnect", &self.disconnect)
         .field("new_secrets", &self.new_secrets)
         .field("connect_interactive", &self.connect_interactive)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMVpnServicePluginClass {
    pub parent: gobject::GObjectClass,
    pub state_changed: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, NMVpnServiceState)>,
    pub ip4_config: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *mut glib::GVariant)>,
    pub login_banner: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *const c_char)>,
    pub failure: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, NMVpnPluginFailure)>,
    pub quit: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin)>,
    pub config: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *mut glib::GVariant)>,
    pub ip6_config: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *mut glib::GVariant)>,
    pub connect: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *mut NMConnection, *mut *mut glib::GError) -> gboolean>,
    pub need_secrets: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *mut NMConnection, *mut *const c_char, *mut *mut glib::GError) -> gboolean>,
    pub disconnect: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *mut *mut glib::GError) -> gboolean>,
    pub new_secrets: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *mut NMConnection, *mut *mut glib::GError) -> gboolean>,
    pub connect_interactive: Option<unsafe extern "C" fn(*mut NMVpnServicePlugin, *mut NMConnection, *mut glib::GVariant, *mut *mut glib::GError) -> gboolean>,
    pub padding: [gpointer; 8],
}

impl ::std::fmt::Debug for NMVpnServicePluginClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnServicePluginClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .field("state_changed", &self.state_changed)
         .field("ip4_config", &self.ip4_config)
         .field("login_banner", &self.login_banner)
         .field("failure", &self.failure)
         .field("quit", &self.quit)
         .field("config", &self.config)
         .field("ip6_config", &self.ip6_config)
         .field("connect", &self.connect)
         .field("need_secrets", &self.need_secrets)
         .field("disconnect", &self.disconnect)
         .field("new_secrets", &self.new_secrets)
         .field("connect_interactive", &self.connect_interactive)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMWimaxNspClass {
    pub parent: NMObjectClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for NMWimaxNspClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMWimaxNspClass @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

// Classes
#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMAccessPoint {
    pub parent: NMObject,
}

impl ::std::fmt::Debug for NMAccessPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMAccessPoint @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMActiveConnection {
    pub parent: NMObject,
}

impl ::std::fmt::Debug for NMActiveConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMActiveConnection @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMClient {
    pub parent: gobject::GObject,
}

impl ::std::fmt::Debug for NMClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMClient @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDevice {
    pub parent: NMObject,
}

impl ::std::fmt::Debug for NMDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDevice @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceAdsl {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceAdsl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceAdsl @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceBond {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceBond {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceBond @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceBridge {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceBridge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceBridge @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceBt {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceBt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceBt @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceDummy {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceDummy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceDummy @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceEthernet {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceEthernet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceEthernet @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceGeneric {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceGeneric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceGeneric @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceIPTunnel {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceIPTunnel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceIPTunnel @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceInfiniband {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceInfiniband {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceInfiniband @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceMacsec {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceMacsec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceMacsec @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceMacvlan {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceMacvlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceMacvlan @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceModem {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceModem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceModem @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceOlpcMesh {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceOlpcMesh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceOlpcMesh @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceTeam {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceTeam @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceTun {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceTun {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceTun @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceVlan {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceVlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceVlan @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceVxlan {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceVxlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceVxlan @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceWifi {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceWifi {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceWifi @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDeviceWimax {
    pub parent: NMDevice,
}

impl ::std::fmt::Debug for NMDeviceWimax {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDeviceWimax @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMDhcpConfig {
    pub parent: NMObject,
}

impl ::std::fmt::Debug for NMDhcpConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMDhcpConfig @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMIPConfig {
    pub parent: NMObject,
}

impl ::std::fmt::Debug for NMIPConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMIPConfig @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMObject {
    pub parent: gobject::GObject,
}

impl ::std::fmt::Debug for NMObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMObject @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMRemoteConnection {
    pub parent: NMObject,
}

impl ::std::fmt::Debug for NMRemoteConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMRemoteConnection @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSecretAgentOld {
    pub parent: gobject::GObject,
}

impl ::std::fmt::Debug for NMSecretAgentOld {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSecretAgentOld @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSetting {
    pub parent: gobject::GObject,
}

impl ::std::fmt::Debug for NMSetting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSetting @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSetting8021x {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSetting8021x {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSetting8021x @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingAdsl {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingAdsl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingAdsl @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingBluetooth {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingBluetooth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBluetooth @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingBond {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingBond {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBond @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingBridge {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingBridge {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBridge @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingBridgePort {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingBridgePort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingBridgePort @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingCdma {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingCdma {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingCdma @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingConnection {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingConnection @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingDcb {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingDcb {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingDcb @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingDummy {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingDummy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingDummy @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingGeneric {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingGeneric {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingGeneric @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingGsm {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingGsm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingGsm @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingIP4Config {
    pub parent: NMSettingIPConfig,
}

impl ::std::fmt::Debug for NMSettingIP4Config {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIP4Config @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingIP6Config {
    pub parent: NMSettingIPConfig,
}

impl ::std::fmt::Debug for NMSettingIP6Config {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIP6Config @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingIPConfig {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingIPConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIPConfig @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingIPTunnel {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingIPTunnel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingIPTunnel @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingInfiniband {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingInfiniband {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingInfiniband @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingMacsec {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingMacsec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingMacsec @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingMacvlan {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingMacvlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingMacvlan @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingOlpcMesh {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingOlpcMesh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingOlpcMesh @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingPpp {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingPpp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingPpp @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingPppoe {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingPppoe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingPppoe @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingProxy {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingProxy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingProxy @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingSerial {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingSerial {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingSerial @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingTeam {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTeam @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingTeamPort {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingTeamPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTeamPort @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingTun {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingTun {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingTun @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
pub struct NMSettingUser(c_void);

impl ::std::fmt::Debug for NMSettingUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingUser @ {:?}", self as *const _))
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingVlan {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingVlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVlan @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingVpn {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingVpn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVpn @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingVxlan {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingVxlan {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingVxlan @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingWimax {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingWimax {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWimax @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingWired {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingWired {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWired @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingWireless {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingWireless {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWireless @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSettingWirelessSecurity {
    pub parent: NMSetting,
}

impl ::std::fmt::Debug for NMSettingWirelessSecurity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSettingWirelessSecurity @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMSimpleConnection {
    pub parent: gobject::GObject,
}

impl ::std::fmt::Debug for NMSimpleConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMSimpleConnection @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMVpnConnection {
    pub parent: NMActiveConnection,
}

impl ::std::fmt::Debug for NMVpnConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnConnection @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMVpnPluginInfo {
    pub parent: gobject::GObject,
}

impl ::std::fmt::Debug for NMVpnPluginInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnPluginInfo @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMVpnPluginOld {
    pub parent: gobject::GObject,
}

impl ::std::fmt::Debug for NMVpnPluginOld {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnPluginOld @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMVpnServicePlugin {
    pub parent: gobject::GObject,
}

impl ::std::fmt::Debug for NMVpnServicePlugin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMVpnServicePlugin @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct NMWimaxNsp {
    pub parent: NMObject,
}

impl ::std::fmt::Debug for NMWimaxNsp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("NMWimaxNsp @ {:?}", self as *const _))
         .field("parent", &self.parent)
         .finish()
    }
}

// Interfaces
#[repr(C)]
pub struct NMConnection(c_void);

impl ::std::fmt::Debug for NMConnection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "NMConnection @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct NMVpnEditor(c_void);

impl ::std::fmt::Debug for NMVpnEditor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "NMVpnEditor @ {:?}", self as *const _)
    }
}

#[repr(C)]
pub struct NMVpnEditorPlugin(c_void);

impl ::std::fmt::Debug for NMVpnEditorPlugin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "NMVpnEditorPlugin @ {:?}", self as *const _)
    }
}


extern "C" {

    //=========================================================================
    // NM80211Mode
    //=========================================================================
    pub fn nm_802_11_mode_get_type() -> GType;

    //=========================================================================
    // NMActiveConnectionState
    //=========================================================================
    pub fn nm_active_connection_state_get_type() -> GType;

    //=========================================================================
    // NMActiveConnectionStateReason
    //=========================================================================
    pub fn nm_active_connection_state_reason_get_type() -> GType;

    //=========================================================================
    // NMAgentManagerError
    //=========================================================================
    pub fn nm_agent_manager_error_get_type() -> GType;
    pub fn nm_agent_manager_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMCapability
    //=========================================================================
    pub fn nm_capability_get_type() -> GType;

    //=========================================================================
    // NMClientError
    //=========================================================================
    pub fn nm_client_error_get_type() -> GType;
    pub fn nm_client_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMClientPermission
    //=========================================================================
    pub fn nm_client_permission_get_type() -> GType;

    //=========================================================================
    // NMClientPermissionResult
    //=========================================================================
    pub fn nm_client_permission_result_get_type() -> GType;

    //=========================================================================
    // NMConnectionError
    //=========================================================================
    pub fn nm_connection_error_get_type() -> GType;
    pub fn nm_connection_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMConnectivityState
    //=========================================================================
    pub fn nm_connectivity_state_get_type() -> GType;

    //=========================================================================
    // NMCryptoError
    //=========================================================================
    pub fn nm_crypto_error_get_type() -> GType;
    pub fn nm_crypto_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMDeviceError
    //=========================================================================
    pub fn nm_device_error_get_type() -> GType;
    pub fn nm_device_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMDeviceState
    //=========================================================================
    pub fn nm_device_state_get_type() -> GType;

    //=========================================================================
    // NMDeviceStateReason
    //=========================================================================
    pub fn nm_device_state_reason_get_type() -> GType;

    //=========================================================================
    // NMDeviceType
    //=========================================================================
    pub fn nm_device_type_get_type() -> GType;

    //=========================================================================
    // NMIPTunnelMode
    //=========================================================================
    pub fn nm_ip_tunnel_mode_get_type() -> GType;

    //=========================================================================
    // NMManagerError
    //=========================================================================
    pub fn nm_manager_error_get_type() -> GType;
    pub fn nm_manager_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMMetered
    //=========================================================================
    pub fn nm_metered_get_type() -> GType;

    //=========================================================================
    // NMSecretAgentError
    //=========================================================================
    pub fn nm_secret_agent_error_get_type() -> GType;
    pub fn nm_secret_agent_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMSetting8021xCKFormat
    //=========================================================================
    pub fn nm_setting_802_1x_ck_format_get_type() -> GType;

    //=========================================================================
    // NMSetting8021xCKScheme
    //=========================================================================
    pub fn nm_setting_802_1x_ck_scheme_get_type() -> GType;

    //=========================================================================
    // NMSettingCompareFlags
    //=========================================================================
    pub fn nm_setting_compare_flags_get_type() -> GType;

    //=========================================================================
    // NMSettingConnectionAutoconnectSlaves
    //=========================================================================
    pub fn nm_setting_connection_autoconnect_slaves_get_type() -> GType;

    //=========================================================================
    // NMSettingConnectionLldp
    //=========================================================================
    pub fn nm_setting_connection_lldp_get_type() -> GType;

    //=========================================================================
    // NMSettingDiffResult
    //=========================================================================
    pub fn nm_setting_diff_result_get_type() -> GType;

    //=========================================================================
    // NMSettingIP6ConfigAddrGenMode
    //=========================================================================
    pub fn nm_setting_ip6_config_addr_gen_mode_get_type() -> GType;

    //=========================================================================
    // NMSettingIP6ConfigPrivacy
    //=========================================================================
    pub fn nm_setting_ip6_config_privacy_get_type() -> GType;

    //=========================================================================
    // NMSettingMacRandomization
    //=========================================================================
    pub fn nm_setting_mac_randomization_get_type() -> GType;

    //=========================================================================
    // NMSettingMacsecMode
    //=========================================================================
    pub fn nm_setting_macsec_mode_get_type() -> GType;

    //=========================================================================
    // NMSettingMacsecValidation
    //=========================================================================
    pub fn nm_setting_macsec_validation_get_type() -> GType;

    //=========================================================================
    // NMSettingMacvlanMode
    //=========================================================================
    pub fn nm_setting_macvlan_mode_get_type() -> GType;

    //=========================================================================
    // NMSettingProxyMethod
    //=========================================================================
    pub fn nm_setting_proxy_method_get_type() -> GType;

    //=========================================================================
    // NMSettingSerialParity
    //=========================================================================
    pub fn nm_setting_serial_parity_get_type() -> GType;

    //=========================================================================
    // NMSettingTunMode
    //=========================================================================
    pub fn nm_setting_tun_mode_get_type() -> GType;

    //=========================================================================
    // NMSettingWirelessPowersave
    //=========================================================================
    pub fn nm_setting_wireless_powersave_get_type() -> GType;

    //=========================================================================
    // NMSettingsError
    //=========================================================================
    pub fn nm_settings_error_get_type() -> GType;
    pub fn nm_settings_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMState
    //=========================================================================
    pub fn nm_state_get_type() -> GType;

    //=========================================================================
    // NMUtilsSecurityType
    //=========================================================================
    pub fn nm_utils_security_type_get_type() -> GType;

    //=========================================================================
    // NMVlanPriorityMap
    //=========================================================================
    pub fn nm_vlan_priority_map_get_type() -> GType;

    //=========================================================================
    // NMVpnConnectionState
    //=========================================================================
    pub fn nm_vpn_connection_state_get_type() -> GType;

    //=========================================================================
    // NMVpnConnectionStateReason
    //=========================================================================
    pub fn nm_vpn_connection_state_reason_get_type() -> GType;

    //=========================================================================
    // NMVpnPluginError
    //=========================================================================
    pub fn nm_vpn_plugin_error_get_type() -> GType;
    pub fn nm_vpn_plugin_error_quark() -> glib::GQuark;

    //=========================================================================
    // NMVpnPluginFailure
    //=========================================================================
    pub fn nm_vpn_plugin_failure_get_type() -> GType;

    //=========================================================================
    // NMVpnServiceState
    //=========================================================================
    pub fn nm_vpn_service_state_get_type() -> GType;

    //=========================================================================
    // NMWepKeyType
    //=========================================================================
    pub fn nm_wep_key_type_get_type() -> GType;

    //=========================================================================
    // NMWimaxNspNetworkType
    //=========================================================================
    pub fn nm_wimax_nsp_network_type_get_type() -> GType;

    //=========================================================================
    // NM80211ApFlags
    //=========================================================================
    pub fn nm_802_11_ap_flags_get_type() -> GType;

    //=========================================================================
    // NM80211ApSecurityFlags
    //=========================================================================
    pub fn nm_802_11_ap_security_flags_get_type() -> GType;

    //=========================================================================
    // NMBluetoothCapabilities
    //=========================================================================
    pub fn nm_bluetooth_capabilities_get_type() -> GType;

    //=========================================================================
    // NMConnectionSerializationFlags
    //=========================================================================
    pub fn nm_connection_serialization_flags_get_type() -> GType;

    //=========================================================================
    // NMDeviceCapabilities
    //=========================================================================
    pub fn nm_device_capabilities_get_type() -> GType;

    //=========================================================================
    // NMDeviceModemCapabilities
    //=========================================================================
    pub fn nm_device_modem_capabilities_get_type() -> GType;

    //=========================================================================
    // NMDeviceWifiCapabilities
    //=========================================================================
    pub fn nm_device_wifi_capabilities_get_type() -> GType;

    //=========================================================================
    // NMSecretAgentCapabilities
    //=========================================================================
    pub fn nm_secret_agent_capabilities_get_type() -> GType;

    //=========================================================================
    // NMSecretAgentGetSecretsFlags
    //=========================================================================
    pub fn nm_secret_agent_get_secrets_flags_get_type() -> GType;

    //=========================================================================
    // NMSetting8021xAuthFlags
    //=========================================================================
    pub fn nm_setting_802_1x_auth_flags_get_type() -> GType;

    //=========================================================================
    // NMSettingDcbFlags
    //=========================================================================
    pub fn nm_setting_dcb_flags_get_type() -> GType;

    //=========================================================================
    // NMSettingSecretFlags
    //=========================================================================
    pub fn nm_setting_secret_flags_get_type() -> GType;

    //=========================================================================
    // NMSettingWiredWakeOnLan
    //=========================================================================
    pub fn nm_setting_wired_wake_on_lan_get_type() -> GType;

    //=========================================================================
    // NMVlanFlags
    //=========================================================================
    pub fn nm_vlan_flags_get_type() -> GType;

    //=========================================================================
    // NMVpnEditorPluginCapability
    //=========================================================================
    pub fn nm_vpn_editor_plugin_capability_get_type() -> GType;

    //=========================================================================
    // NMDnsEntry
    //=========================================================================
    pub fn nm_dns_entry_get_type() -> GType;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_dns_entry_get_domains(entry: *mut NMDnsEntry) -> *const *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_dns_entry_get_interface(entry: *mut NMDnsEntry) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_dns_entry_get_nameservers(entry: *mut NMDnsEntry) -> *const *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_dns_entry_get_priority(entry: *mut NMDnsEntry) -> c_int;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_dns_entry_get_vpn(entry: *mut NMDnsEntry) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_dns_entry_unref(entry: *mut NMDnsEntry);

    //=========================================================================
    // NMIPAddress
    //=========================================================================
    pub fn nm_ip_address_get_type() -> GType;
    pub fn nm_ip_address_new(family: c_int, addr: *const c_char, prefix: c_uint, error: *mut *mut glib::GError) -> *mut NMIPAddress;
    pub fn nm_ip_address_new_binary(family: c_int, addr: gconstpointer, prefix: c_uint, error: *mut *mut glib::GError) -> *mut NMIPAddress;
    pub fn nm_ip_address_dup(address: *mut NMIPAddress) -> *mut NMIPAddress;
    pub fn nm_ip_address_equal(address: *mut NMIPAddress, other: *mut NMIPAddress) -> gboolean;
    pub fn nm_ip_address_get_address(address: *mut NMIPAddress) -> *const c_char;
    pub fn nm_ip_address_get_address_binary(address: *mut NMIPAddress, addr: gpointer);
    pub fn nm_ip_address_get_attribute(address: *mut NMIPAddress, name: *const c_char) -> *mut glib::GVariant;
    pub fn nm_ip_address_get_attribute_names(address: *mut NMIPAddress) -> *mut *mut c_char;
    pub fn nm_ip_address_get_family(address: *mut NMIPAddress) -> c_int;
    pub fn nm_ip_address_get_prefix(address: *mut NMIPAddress) -> c_uint;
    pub fn nm_ip_address_ref(address: *mut NMIPAddress);
    pub fn nm_ip_address_set_address(address: *mut NMIPAddress, addr: *const c_char);
    pub fn nm_ip_address_set_address_binary(address: *mut NMIPAddress, addr: gconstpointer);
    pub fn nm_ip_address_set_attribute(address: *mut NMIPAddress, name: *const c_char, value: *mut glib::GVariant);
    pub fn nm_ip_address_set_prefix(address: *mut NMIPAddress, prefix: c_uint);
    pub fn nm_ip_address_unref(address: *mut NMIPAddress);

    //=========================================================================
    // NMIPRoute
    //=========================================================================
    pub fn nm_ip_route_get_type() -> GType;
    pub fn nm_ip_route_new(family: c_int, dest: *const c_char, prefix: c_uint, next_hop: *const c_char, metric: i64, error: *mut *mut glib::GError) -> *mut NMIPRoute;
    pub fn nm_ip_route_new_binary(family: c_int, dest: gconstpointer, prefix: c_uint, next_hop: gconstpointer, metric: i64, error: *mut *mut glib::GError) -> *mut NMIPRoute;
    pub fn nm_ip_route_dup(route: *mut NMIPRoute) -> *mut NMIPRoute;
    pub fn nm_ip_route_equal(route: *mut NMIPRoute, other: *mut NMIPRoute) -> gboolean;
    pub fn nm_ip_route_get_attribute(route: *mut NMIPRoute, name: *const c_char) -> *mut glib::GVariant;
    pub fn nm_ip_route_get_attribute_names(route: *mut NMIPRoute) -> *mut *mut c_char;
    pub fn nm_ip_route_get_dest(route: *mut NMIPRoute) -> *const c_char;
    pub fn nm_ip_route_get_dest_binary(route: *mut NMIPRoute, dest: gpointer);
    pub fn nm_ip_route_get_family(route: *mut NMIPRoute) -> c_int;
    pub fn nm_ip_route_get_metric(route: *mut NMIPRoute) -> i64;
    pub fn nm_ip_route_get_next_hop(route: *mut NMIPRoute) -> *const c_char;
    pub fn nm_ip_route_get_next_hop_binary(route: *mut NMIPRoute, next_hop: gpointer) -> gboolean;
    pub fn nm_ip_route_get_prefix(route: *mut NMIPRoute) -> c_uint;
    pub fn nm_ip_route_ref(route: *mut NMIPRoute);
    pub fn nm_ip_route_set_attribute(route: *mut NMIPRoute, name: *const c_char, value: *mut glib::GVariant);
    pub fn nm_ip_route_set_dest(route: *mut NMIPRoute, dest: *const c_char);
    pub fn nm_ip_route_set_dest_binary(route: *mut NMIPRoute, dest: gconstpointer);
    pub fn nm_ip_route_set_metric(route: *mut NMIPRoute, metric: i64);
    pub fn nm_ip_route_set_next_hop(route: *mut NMIPRoute, next_hop: *const c_char);
    pub fn nm_ip_route_set_next_hop_binary(route: *mut NMIPRoute, next_hop: gconstpointer);
    pub fn nm_ip_route_set_prefix(route: *mut NMIPRoute, prefix: c_uint);
    pub fn nm_ip_route_unref(route: *mut NMIPRoute);
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_ip_route_attribute_validate(name: *const c_char, value: *mut glib::GVariant, family: c_int, known: *mut gboolean, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_ip_route_get_variant_attribute_spec() -> *const *const NMVariantAttributeSpec;

    //=========================================================================
    // NMLldpNeighbor
    //=========================================================================
    pub fn nm_lldp_neighbor_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_lldp_neighbor_new() -> *mut NMLldpNeighbor;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_lldp_neighbor_get_attr_names(neighbor: *mut NMLldpNeighbor) -> *mut *mut c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_lldp_neighbor_get_attr_string_value(neighbor: *mut NMLldpNeighbor, name: *mut c_char, out_value: *mut *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_lldp_neighbor_get_attr_type(neighbor: *mut NMLldpNeighbor, name: *mut c_char) -> *const glib::GVariantType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_lldp_neighbor_get_attr_uint_value(neighbor: *mut NMLldpNeighbor, name: *mut c_char, out_value: *mut c_uint) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_lldp_neighbor_ref(neighbor: *mut NMLldpNeighbor);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_lldp_neighbor_unref(neighbor: *mut NMLldpNeighbor);

    //=========================================================================
    // NMAccessPoint
    //=========================================================================
    pub fn nm_access_point_get_type() -> GType;
    pub fn nm_access_point_connection_valid(ap: *mut NMAccessPoint, connection: *mut NMConnection) -> gboolean;
    pub fn nm_access_point_filter_connections(ap: *mut NMAccessPoint, connections: *const glib::GPtrArray) -> *mut glib::GPtrArray;
    pub fn nm_access_point_get_bssid(ap: *mut NMAccessPoint) -> *const c_char;
    pub fn nm_access_point_get_flags(ap: *mut NMAccessPoint) -> NM80211ApFlags;
    pub fn nm_access_point_get_frequency(ap: *mut NMAccessPoint) -> u32;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_access_point_get_last_seen(ap: *mut NMAccessPoint) -> c_int;
    pub fn nm_access_point_get_max_bitrate(ap: *mut NMAccessPoint) -> u32;
    pub fn nm_access_point_get_mode(ap: *mut NMAccessPoint) -> NM80211Mode;
    pub fn nm_access_point_get_rsn_flags(ap: *mut NMAccessPoint) -> NM80211ApSecurityFlags;
    pub fn nm_access_point_get_ssid(ap: *mut NMAccessPoint) -> *mut glib::GBytes;
    pub fn nm_access_point_get_strength(ap: *mut NMAccessPoint) -> u8;
    pub fn nm_access_point_get_wpa_flags(ap: *mut NMAccessPoint) -> NM80211ApSecurityFlags;

    //=========================================================================
    // NMActiveConnection
    //=========================================================================
    pub fn nm_active_connection_get_type() -> GType;
    pub fn nm_active_connection_get_connection(connection: *mut NMActiveConnection) -> *mut NMRemoteConnection;
    pub fn nm_active_connection_get_connection_type(connection: *mut NMActiveConnection) -> *const c_char;
    pub fn nm_active_connection_get_default(connection: *mut NMActiveConnection) -> gboolean;
    pub fn nm_active_connection_get_default6(connection: *mut NMActiveConnection) -> gboolean;
    pub fn nm_active_connection_get_devices(connection: *mut NMActiveConnection) -> *const glib::GPtrArray;
    pub fn nm_active_connection_get_dhcp4_config(connection: *mut NMActiveConnection) -> *mut NMDhcpConfig;
    pub fn nm_active_connection_get_dhcp6_config(connection: *mut NMActiveConnection) -> *mut NMDhcpConfig;
    pub fn nm_active_connection_get_id(connection: *mut NMActiveConnection) -> *const c_char;
    pub fn nm_active_connection_get_ip4_config(connection: *mut NMActiveConnection) -> *mut NMIPConfig;
    pub fn nm_active_connection_get_ip6_config(connection: *mut NMActiveConnection) -> *mut NMIPConfig;
    pub fn nm_active_connection_get_master(connection: *mut NMActiveConnection) -> *mut NMDevice;
    pub fn nm_active_connection_get_specific_object_path(connection: *mut NMActiveConnection) -> *const c_char;
    pub fn nm_active_connection_get_state(connection: *mut NMActiveConnection) -> NMActiveConnectionState;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_active_connection_get_state_reason(connection: *mut NMActiveConnection) -> NMActiveConnectionStateReason;
    pub fn nm_active_connection_get_uuid(connection: *mut NMActiveConnection) -> *const c_char;
    pub fn nm_active_connection_get_vpn(connection: *mut NMActiveConnection) -> gboolean;

    //=========================================================================
    // NMClient
    //=========================================================================
    pub fn nm_client_get_type() -> GType;
    pub fn nm_client_new(cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut NMClient;
    pub fn nm_client_new_finish(result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut NMClient;
    pub fn nm_client_new_async(cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_activate_connection_async(client: *mut NMClient, connection: *mut NMConnection, device: *mut NMDevice, specific_object: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_activate_connection_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut NMActiveConnection;
    pub fn nm_client_add_and_activate_connection_async(client: *mut NMClient, partial: *mut NMConnection, device: *mut NMDevice, specific_object: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_add_and_activate_connection_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut NMActiveConnection;
    pub fn nm_client_add_connection_async(client: *mut NMClient, connection: *mut NMConnection, save_to_disk: gboolean, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_add_connection_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut NMRemoteConnection;
    pub fn nm_client_check_connectivity(client: *mut NMClient, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> NMConnectivityState;
    pub fn nm_client_check_connectivity_async(client: *mut NMClient, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_check_connectivity_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> NMConnectivityState;
    pub fn nm_client_deactivate_connection(client: *mut NMClient, active: *mut NMActiveConnection, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_deactivate_connection_async(client: *mut NMClient, active: *mut NMActiveConnection, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_deactivate_connection_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_get_activating_connection(client: *mut NMClient) -> *mut NMActiveConnection;
    pub fn nm_client_get_active_connections(client: *mut NMClient) -> *const glib::GPtrArray;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_client_get_all_devices(client: *mut NMClient) -> *const glib::GPtrArray;
    pub fn nm_client_get_connection_by_id(client: *mut NMClient, id: *const c_char) -> *mut NMRemoteConnection;
    pub fn nm_client_get_connection_by_path(client: *mut NMClient, path: *const c_char) -> *mut NMRemoteConnection;
    pub fn nm_client_get_connection_by_uuid(client: *mut NMClient, uuid: *const c_char) -> *mut NMRemoteConnection;
    pub fn nm_client_get_connections(client: *mut NMClient) -> *const glib::GPtrArray;
    pub fn nm_client_get_connectivity(client: *mut NMClient) -> NMConnectivityState;
    pub fn nm_client_get_device_by_iface(client: *mut NMClient, iface: *const c_char) -> *mut NMDevice;
    pub fn nm_client_get_device_by_path(client: *mut NMClient, object_path: *const c_char) -> *mut NMDevice;
    pub fn nm_client_get_devices(client: *mut NMClient) -> *const glib::GPtrArray;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_client_get_dns_configuration(client: *mut NMClient) -> *const glib::GPtrArray;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_client_get_dns_mode(client: *mut NMClient) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_client_get_dns_rc_manager(client: *mut NMClient) -> *const c_char;
    pub fn nm_client_get_logging(client: *mut NMClient, level: *mut *mut c_char, domains: *mut *mut c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_get_nm_running(client: *mut NMClient) -> gboolean;
    pub fn nm_client_get_permission_result(client: *mut NMClient, permission: NMClientPermission) -> NMClientPermissionResult;
    pub fn nm_client_get_primary_connection(client: *mut NMClient) -> *mut NMActiveConnection;
    pub fn nm_client_get_startup(client: *mut NMClient) -> gboolean;
    pub fn nm_client_get_state(client: *mut NMClient) -> NMState;
    pub fn nm_client_get_version(client: *mut NMClient) -> *const c_char;
    pub fn nm_client_load_connections(client: *mut NMClient, filenames: *mut *mut c_char, failures: *mut *mut *mut c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_load_connections_async(client: *mut NMClient, filenames: *mut *mut c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_load_connections_finish(client: *mut NMClient, failures: *mut *mut *mut c_char, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_networking_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_networking_set_enabled(client: *mut NMClient, enabled: gboolean, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_reload_connections(client: *mut NMClient, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_reload_connections_async(client: *mut NMClient, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_reload_connections_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_save_hostname(client: *mut NMClient, hostname: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_save_hostname_async(client: *mut NMClient, hostname: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_client_save_hostname_finish(client: *mut NMClient, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_set_logging(client: *mut NMClient, level: *const c_char, domains: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_client_wimax_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wimax_hardware_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wimax_set_enabled(client: *mut NMClient, enabled: gboolean);
    pub fn nm_client_wireless_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wireless_hardware_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wireless_set_enabled(client: *mut NMClient, enabled: gboolean);
    pub fn nm_client_wwan_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wwan_hardware_get_enabled(client: *mut NMClient) -> gboolean;
    pub fn nm_client_wwan_set_enabled(client: *mut NMClient, enabled: gboolean);

    //=========================================================================
    // NMDevice
    //=========================================================================
    pub fn nm_device_get_type() -> GType;
    pub fn nm_device_disambiguate_names(devices: *mut *mut NMDevice, num_devices: c_int) -> *mut *mut c_char;
    pub fn nm_device_connection_compatible(device: *mut NMDevice, connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_connection_valid(device: *mut NMDevice, connection: *mut NMConnection) -> gboolean;
    pub fn nm_device_delete(device: *mut NMDevice, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_delete_async(device: *mut NMDevice, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_device_delete_finish(device: *mut NMDevice, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_disconnect(device: *mut NMDevice, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_disconnect_async(device: *mut NMDevice, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_device_disconnect_finish(device: *mut NMDevice, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_filter_connections(device: *mut NMDevice, connections: *const glib::GPtrArray) -> *mut glib::GPtrArray;
    pub fn nm_device_get_active_connection(device: *mut NMDevice) -> *mut NMActiveConnection;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_get_applied_connection(device: *mut NMDevice, flags: u32, version_id: *mut u64, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut NMConnection;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_get_applied_connection_async(device: *mut NMDevice, flags: u32, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_get_applied_connection_finish(device: *mut NMDevice, result: *mut gio::GAsyncResult, version_id: *mut u64, error: *mut *mut glib::GError) -> *mut NMConnection;
    pub fn nm_device_get_autoconnect(device: *mut NMDevice) -> gboolean;
    pub fn nm_device_get_available_connections(device: *mut NMDevice) -> *const glib::GPtrArray;
    pub fn nm_device_get_capabilities(device: *mut NMDevice) -> NMDeviceCapabilities;
    pub fn nm_device_get_description(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_device_type(device: *mut NMDevice) -> NMDeviceType;
    pub fn nm_device_get_dhcp4_config(device: *mut NMDevice) -> *mut NMDhcpConfig;
    pub fn nm_device_get_dhcp6_config(device: *mut NMDevice) -> *mut NMDhcpConfig;
    pub fn nm_device_get_driver(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_driver_version(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_firmware_missing(device: *mut NMDevice) -> gboolean;
    pub fn nm_device_get_firmware_version(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_hw_address(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_iface(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_ip4_config(device: *mut NMDevice) -> *mut NMIPConfig;
    pub fn nm_device_get_ip6_config(device: *mut NMDevice) -> *mut NMIPConfig;
    pub fn nm_device_get_ip_iface(device: *mut NMDevice) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_get_lldp_neighbors(device: *mut NMDevice) -> *mut glib::GPtrArray;
    pub fn nm_device_get_managed(device: *mut NMDevice) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_get_metered(device: *mut NMDevice) -> NMMetered;
    pub fn nm_device_get_mtu(device: *mut NMDevice) -> u32;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_get_nm_plugin_missing(device: *mut NMDevice) -> gboolean;
    pub fn nm_device_get_physical_port_id(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_product(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_setting_type(device: *mut NMDevice) -> GType;
    pub fn nm_device_get_state(device: *mut NMDevice) -> NMDeviceState;
    pub fn nm_device_get_state_reason(device: *mut NMDevice) -> NMDeviceStateReason;
    pub fn nm_device_get_type_description(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_udi(device: *mut NMDevice) -> *const c_char;
    pub fn nm_device_get_vendor(device: *mut NMDevice) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_is_real(device: *mut NMDevice) -> gboolean;
    pub fn nm_device_is_software(device: *mut NMDevice) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_reapply(device: *mut NMDevice, connection: *mut NMConnection, version_id: u64, flags: u32, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_reapply_async(device: *mut NMDevice, connection: *mut NMConnection, version_id: u64, flags: u32, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_reapply_finish(device: *mut NMDevice, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_set_autoconnect(device: *mut NMDevice, autoconnect: gboolean);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_set_managed(device: *mut NMDevice, managed: gboolean);

    //=========================================================================
    // NMDeviceAdsl
    //=========================================================================
    pub fn nm_device_adsl_get_type() -> GType;
    pub fn nm_device_adsl_get_carrier(device: *mut NMDeviceAdsl) -> gboolean;

    //=========================================================================
    // NMDeviceBond
    //=========================================================================
    pub fn nm_device_bond_get_type() -> GType;
    pub fn nm_device_bond_get_carrier(device: *mut NMDeviceBond) -> gboolean;
    pub fn nm_device_bond_get_hw_address(device: *mut NMDeviceBond) -> *const c_char;
    pub fn nm_device_bond_get_slaves(device: *mut NMDeviceBond) -> *const glib::GPtrArray;

    //=========================================================================
    // NMDeviceBridge
    //=========================================================================
    pub fn nm_device_bridge_get_type() -> GType;
    pub fn nm_device_bridge_get_carrier(device: *mut NMDeviceBridge) -> gboolean;
    pub fn nm_device_bridge_get_hw_address(device: *mut NMDeviceBridge) -> *const c_char;
    pub fn nm_device_bridge_get_slaves(device: *mut NMDeviceBridge) -> *const glib::GPtrArray;

    //=========================================================================
    // NMDeviceBt
    //=========================================================================
    pub fn nm_device_bt_get_type() -> GType;
    pub fn nm_device_bt_get_capabilities(device: *mut NMDeviceBt) -> NMBluetoothCapabilities;
    pub fn nm_device_bt_get_hw_address(device: *mut NMDeviceBt) -> *const c_char;
    pub fn nm_device_bt_get_name(device: *mut NMDeviceBt) -> *const c_char;

    //=========================================================================
    // NMDeviceDummy
    //=========================================================================
    pub fn nm_device_dummy_get_type() -> GType;

    //=========================================================================
    // NMDeviceEthernet
    //=========================================================================
    pub fn nm_device_ethernet_get_type() -> GType;
    pub fn nm_device_ethernet_get_carrier(device: *mut NMDeviceEthernet) -> gboolean;
    pub fn nm_device_ethernet_get_hw_address(device: *mut NMDeviceEthernet) -> *const c_char;
    pub fn nm_device_ethernet_get_permanent_hw_address(device: *mut NMDeviceEthernet) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ethernet_get_s390_subchannels(device: *mut NMDeviceEthernet) -> *const *const c_char;
    pub fn nm_device_ethernet_get_speed(device: *mut NMDeviceEthernet) -> u32;

    //=========================================================================
    // NMDeviceGeneric
    //=========================================================================
    pub fn nm_device_generic_get_type() -> GType;
    pub fn nm_device_generic_get_hw_address(device: *mut NMDeviceGeneric) -> *const c_char;

    //=========================================================================
    // NMDeviceIPTunnel
    //=========================================================================
    pub fn nm_device_ip_tunnel_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_encapsulation_limit(device: *mut NMDeviceIPTunnel) -> u8;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_flow_label(device: *mut NMDeviceIPTunnel) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_input_key(device: *mut NMDeviceIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_local(device: *mut NMDeviceIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_mode(device: *mut NMDeviceIPTunnel) -> NMIPTunnelMode;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_output_key(device: *mut NMDeviceIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_parent(device: *mut NMDeviceIPTunnel) -> *mut NMDevice;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_path_mtu_discovery(device: *mut NMDeviceIPTunnel) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_remote(device: *mut NMDeviceIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_tos(device: *mut NMDeviceIPTunnel) -> u8;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_ip_tunnel_get_ttl(device: *mut NMDeviceIPTunnel) -> u8;

    //=========================================================================
    // NMDeviceInfiniband
    //=========================================================================
    pub fn nm_device_infiniband_get_type() -> GType;
    pub fn nm_device_infiniband_get_carrier(device: *mut NMDeviceInfiniband) -> gboolean;
    pub fn nm_device_infiniband_get_hw_address(device: *mut NMDeviceInfiniband) -> *const c_char;

    //=========================================================================
    // NMDeviceMacsec
    //=========================================================================
    pub fn nm_device_macsec_get_type() -> GType;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_cipher_suite(device: *mut NMDeviceMacsec) -> u64;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_encoding_sa(device: *mut NMDeviceMacsec) -> u8;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_encrypt(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_es(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_hw_address(device: *mut NMDeviceMacsec) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_icv_length(device: *mut NMDeviceMacsec) -> u8;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_include_sci(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_parent(device: *mut NMDeviceMacsec) -> *mut NMDevice;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_protect(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_replay_protect(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_scb(device: *mut NMDeviceMacsec) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_sci(device: *mut NMDeviceMacsec) -> u64;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_validation(device: *mut NMDeviceMacsec) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_device_macsec_get_window(device: *mut NMDeviceMacsec) -> c_uint;

    //=========================================================================
    // NMDeviceMacvlan
    //=========================================================================
    pub fn nm_device_macvlan_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_macvlan_get_hw_address(device: *mut NMDeviceMacvlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_macvlan_get_mode(device: *mut NMDeviceMacvlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_macvlan_get_no_promisc(device: *mut NMDeviceMacvlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_macvlan_get_parent(device: *mut NMDeviceMacvlan) -> *mut NMDevice;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_macvlan_get_tap(device: *mut NMDeviceMacvlan) -> gboolean;

    //=========================================================================
    // NMDeviceModem
    //=========================================================================
    pub fn nm_device_modem_get_type() -> GType;
    pub fn nm_device_modem_get_current_capabilities(self_: *mut NMDeviceModem) -> NMDeviceModemCapabilities;
    pub fn nm_device_modem_get_modem_capabilities(self_: *mut NMDeviceModem) -> NMDeviceModemCapabilities;

    //=========================================================================
    // NMDeviceOlpcMesh
    //=========================================================================
    pub fn nm_device_olpc_mesh_get_type() -> GType;
    pub fn nm_device_olpc_mesh_get_active_channel(device: *mut NMDeviceOlpcMesh) -> u32;
    pub fn nm_device_olpc_mesh_get_companion(device: *mut NMDeviceOlpcMesh) -> *mut NMDeviceWifi;
    pub fn nm_device_olpc_mesh_get_hw_address(device: *mut NMDeviceOlpcMesh) -> *const c_char;

    //=========================================================================
    // NMDeviceTeam
    //=========================================================================
    pub fn nm_device_team_get_type() -> GType;
    pub fn nm_device_team_get_carrier(device: *mut NMDeviceTeam) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_device_team_get_config(device: *mut NMDeviceTeam) -> *const c_char;
    pub fn nm_device_team_get_hw_address(device: *mut NMDeviceTeam) -> *const c_char;
    pub fn nm_device_team_get_slaves(device: *mut NMDeviceTeam) -> *const glib::GPtrArray;

    //=========================================================================
    // NMDeviceTun
    //=========================================================================
    pub fn nm_device_tun_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_tun_get_group(device: *mut NMDeviceTun) -> i64;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_tun_get_hw_address(device: *mut NMDeviceTun) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_tun_get_mode(device: *mut NMDeviceTun) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_tun_get_multi_queue(device: *mut NMDeviceTun) -> gboolean;
    pub fn nm_device_tun_get_no_pi(device: *mut NMDeviceTun) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_tun_get_owner(device: *mut NMDeviceTun) -> i64;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_tun_get_vnet_hdr(device: *mut NMDeviceTun) -> gboolean;

    //=========================================================================
    // NMDeviceVlan
    //=========================================================================
    pub fn nm_device_vlan_get_type() -> GType;
    pub fn nm_device_vlan_get_carrier(device: *mut NMDeviceVlan) -> gboolean;
    pub fn nm_device_vlan_get_hw_address(device: *mut NMDeviceVlan) -> *const c_char;
    pub fn nm_device_vlan_get_parent(device: *mut NMDeviceVlan) -> *mut NMDevice;
    pub fn nm_device_vlan_get_vlan_id(device: *mut NMDeviceVlan) -> c_uint;

    //=========================================================================
    // NMDeviceVxlan
    //=========================================================================
    pub fn nm_device_vxlan_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_ageing(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_carrier(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_dst_port(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_group(device: *mut NMDeviceVxlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_hw_address(device: *mut NMDeviceVxlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_id(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_l2miss(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_l3miss(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_learning(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_limit(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_local(device: *mut NMDeviceVxlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_parent(device: *mut NMDeviceVxlan) -> *mut NMDevice;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_proxy(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_rsc(device: *mut NMDeviceVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_src_port_max(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_src_port_min(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_tos(device: *mut NMDeviceVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_vxlan_get_ttl(device: *mut NMDeviceVxlan) -> c_uint;

    //=========================================================================
    // NMDeviceWifi
    //=========================================================================
    pub fn nm_device_wifi_get_type() -> GType;
    pub fn nm_device_wifi_get_access_point_by_path(device: *mut NMDeviceWifi, path: *const c_char) -> *mut NMAccessPoint;
    pub fn nm_device_wifi_get_access_points(device: *mut NMDeviceWifi) -> *const glib::GPtrArray;
    pub fn nm_device_wifi_get_active_access_point(device: *mut NMDeviceWifi) -> *mut NMAccessPoint;
    pub fn nm_device_wifi_get_bitrate(device: *mut NMDeviceWifi) -> u32;
    pub fn nm_device_wifi_get_capabilities(device: *mut NMDeviceWifi) -> NMDeviceWifiCapabilities;
    pub fn nm_device_wifi_get_hw_address(device: *mut NMDeviceWifi) -> *const c_char;
    pub fn nm_device_wifi_get_mode(device: *mut NMDeviceWifi) -> NM80211Mode;
    pub fn nm_device_wifi_get_permanent_hw_address(device: *mut NMDeviceWifi) -> *const c_char;
    pub fn nm_device_wifi_request_scan(device: *mut NMDeviceWifi, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_device_wifi_request_scan_async(device: *mut NMDeviceWifi, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_device_wifi_request_scan_finish(device: *mut NMDeviceWifi, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_wifi_request_scan_options(device: *mut NMDeviceWifi, options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_device_wifi_request_scan_options_async(device: *mut NMDeviceWifi, options: *mut glib::GVariant, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);

    //=========================================================================
    // NMDeviceWimax
    //=========================================================================
    pub fn nm_device_wimax_get_type() -> GType;
    pub fn nm_device_wimax_get_active_nsp(wimax: *mut NMDeviceWimax) -> *mut NMWimaxNsp;
    pub fn nm_device_wimax_get_bsid(self_: *mut NMDeviceWimax) -> *const c_char;
    pub fn nm_device_wimax_get_center_frequency(self_: *mut NMDeviceWimax) -> c_uint;
    pub fn nm_device_wimax_get_cinr(self_: *mut NMDeviceWimax) -> c_int;
    pub fn nm_device_wimax_get_hw_address(wimax: *mut NMDeviceWimax) -> *const c_char;
    pub fn nm_device_wimax_get_nsp_by_path(wimax: *mut NMDeviceWimax, path: *const c_char) -> *mut NMWimaxNsp;
    pub fn nm_device_wimax_get_nsps(wimax: *mut NMDeviceWimax) -> *const glib::GPtrArray;
    pub fn nm_device_wimax_get_rssi(self_: *mut NMDeviceWimax) -> c_int;
    pub fn nm_device_wimax_get_tx_power(self_: *mut NMDeviceWimax) -> c_int;

    //=========================================================================
    // NMDhcpConfig
    //=========================================================================
    pub fn nm_dhcp_config_get_type() -> GType;
    pub fn nm_dhcp_config_get_family(config: *mut NMDhcpConfig) -> c_int;
    pub fn nm_dhcp_config_get_one_option(config: *mut NMDhcpConfig, option: *const c_char) -> *const c_char;
    pub fn nm_dhcp_config_get_options(config: *mut NMDhcpConfig) -> *mut glib::GHashTable;

    //=========================================================================
    // NMIPConfig
    //=========================================================================
    pub fn nm_ip_config_get_type() -> GType;
    pub fn nm_ip_config_get_addresses(config: *mut NMIPConfig) -> *mut glib::GPtrArray;
    pub fn nm_ip_config_get_domains(config: *mut NMIPConfig) -> *const *const c_char;
    pub fn nm_ip_config_get_family(config: *mut NMIPConfig) -> c_int;
    pub fn nm_ip_config_get_gateway(config: *mut NMIPConfig) -> *const c_char;
    pub fn nm_ip_config_get_nameservers(config: *mut NMIPConfig) -> *const *const c_char;
    pub fn nm_ip_config_get_routes(config: *mut NMIPConfig) -> *mut glib::GPtrArray;
    pub fn nm_ip_config_get_searches(config: *mut NMIPConfig) -> *const *const c_char;
    pub fn nm_ip_config_get_wins_servers(config: *mut NMIPConfig) -> *const *const c_char;

    //=========================================================================
    // NMObject
    //=========================================================================
    pub fn nm_object_get_type() -> GType;
    pub fn nm_object_get_path(object: *mut NMObject) -> *const c_char;

    //=========================================================================
    // NMRemoteConnection
    //=========================================================================
    pub fn nm_remote_connection_get_type() -> GType;
    pub fn nm_remote_connection_commit_changes(connection: *mut NMRemoteConnection, save_to_disk: gboolean, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_remote_connection_commit_changes_async(connection: *mut NMRemoteConnection, save_to_disk: gboolean, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_remote_connection_commit_changes_finish(connection: *mut NMRemoteConnection, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_remote_connection_delete(connection: *mut NMRemoteConnection, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_remote_connection_delete_async(connection: *mut NMRemoteConnection, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_remote_connection_delete_finish(connection: *mut NMRemoteConnection, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_remote_connection_get_secrets(connection: *mut NMRemoteConnection, setting_name: *const c_char, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    pub fn nm_remote_connection_get_secrets_async(connection: *mut NMRemoteConnection, setting_name: *const c_char, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_remote_connection_get_secrets_finish(connection: *mut NMRemoteConnection, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> *mut glib::GVariant;
    pub fn nm_remote_connection_get_unsaved(connection: *mut NMRemoteConnection) -> gboolean;
    pub fn nm_remote_connection_get_visible(connection: *mut NMRemoteConnection) -> gboolean;
    pub fn nm_remote_connection_save(connection: *mut NMRemoteConnection, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_remote_connection_save_async(connection: *mut NMRemoteConnection, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_remote_connection_save_finish(connection: *mut NMRemoteConnection, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMSecretAgentOld
    //=========================================================================
    pub fn nm_secret_agent_old_get_type() -> GType;
    pub fn nm_secret_agent_old_delete_secrets(self_: *mut NMSecretAgentOld, connection: *mut NMConnection, callback: NMSecretAgentOldDeleteSecretsFunc, user_data: gpointer);
    pub fn nm_secret_agent_old_get_registered(self_: *mut NMSecretAgentOld) -> gboolean;
    pub fn nm_secret_agent_old_get_secrets(self_: *mut NMSecretAgentOld, connection: *mut NMConnection, setting_name: *const c_char, hints: *mut *mut c_char, flags: NMSecretAgentGetSecretsFlags, callback: NMSecretAgentOldGetSecretsFunc, user_data: gpointer);
    pub fn nm_secret_agent_old_register(self_: *mut NMSecretAgentOld, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_secret_agent_old_register_async(self_: *mut NMSecretAgentOld, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_secret_agent_old_register_finish(self_: *mut NMSecretAgentOld, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_secret_agent_old_save_secrets(self_: *mut NMSecretAgentOld, connection: *mut NMConnection, callback: NMSecretAgentOldSaveSecretsFunc, user_data: gpointer);
    pub fn nm_secret_agent_old_unregister(self_: *mut NMSecretAgentOld, cancellable: *mut gio::GCancellable, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_secret_agent_old_unregister_async(self_: *mut NMSecretAgentOld, cancellable: *mut gio::GCancellable, callback: gio::GAsyncReadyCallback, user_data: gpointer);
    pub fn nm_secret_agent_old_unregister_finish(self_: *mut NMSecretAgentOld, result: *mut gio::GAsyncResult, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMSetting
    //=========================================================================
    pub fn nm_setting_get_type() -> GType;
    pub fn nm_setting_lookup_type(name: *const c_char) -> GType;
    pub fn nm_setting_compare(a: *mut NMSetting, b: *mut NMSetting, flags: NMSettingCompareFlags) -> gboolean;
    pub fn nm_setting_diff(a: *mut NMSetting, b: *mut NMSetting, flags: NMSettingCompareFlags, invert_results: gboolean, results: *mut *mut glib::GHashTable) -> gboolean;
    pub fn nm_setting_duplicate(setting: *mut NMSetting) -> *mut NMSetting;
    pub fn nm_setting_enumerate_values(setting: *mut NMSetting, func: NMSettingValueIterFn, user_data: gpointer);
    pub fn nm_setting_get_dbus_property_type(setting: *mut NMSetting, property_name: *const c_char) -> *const glib::GVariantType;
    pub fn nm_setting_get_name(setting: *mut NMSetting) -> *const c_char;
    pub fn nm_setting_get_secret_flags(setting: *mut NMSetting, secret_name: *const c_char, out_flags: *mut NMSettingSecretFlags, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_setting_set_secret_flags(setting: *mut NMSetting, secret_name: *const c_char, flags: NMSettingSecretFlags, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_setting_to_string(setting: *mut NMSetting) -> *mut c_char;
    pub fn nm_setting_verify(setting: *mut NMSetting, connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_verify_secrets(setting: *mut NMSetting, connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMSetting8021x
    //=========================================================================
    pub fn nm_setting_802_1x_get_type() -> GType;
    pub fn nm_setting_802_1x_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_802_1x_check_cert_scheme(pdata: gconstpointer, length: size_t, error: *mut *mut glib::GError) -> NMSetting8021xCKScheme;
    pub fn nm_setting_802_1x_add_altsubject_match(setting: *mut NMSetting8021x, altsubject_match: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_add_eap_method(setting: *mut NMSetting8021x, eap: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_add_phase2_altsubject_match(setting: *mut NMSetting8021x, phase2_altsubject_match: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_clear_altsubject_matches(setting: *mut NMSetting8021x);
    pub fn nm_setting_802_1x_clear_eap_methods(setting: *mut NMSetting8021x);
    pub fn nm_setting_802_1x_clear_phase2_altsubject_matches(setting: *mut NMSetting8021x);
    pub fn nm_setting_802_1x_get_altsubject_match(setting: *mut NMSetting8021x, i: u32) -> *const c_char;
    pub fn nm_setting_802_1x_get_anonymous_identity(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_auth_timeout(setting: *mut NMSetting8021x) -> c_int;
    pub fn nm_setting_802_1x_get_ca_cert_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_ca_cert_password(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_ca_cert_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_ca_cert_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_ca_cert_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_802_1x_get_ca_cert_uri(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_ca_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_client_cert_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_client_cert_password(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_client_cert_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_client_cert_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_client_cert_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_802_1x_get_client_cert_uri(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_802_1x_get_domain_suffix_match(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_eap_method(setting: *mut NMSetting8021x, i: u32) -> *const c_char;
    pub fn nm_setting_802_1x_get_identity(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_num_altsubject_matches(setting: *mut NMSetting8021x) -> u32;
    pub fn nm_setting_802_1x_get_num_eap_methods(setting: *mut NMSetting8021x) -> u32;
    pub fn nm_setting_802_1x_get_num_phase2_altsubject_matches(setting: *mut NMSetting8021x) -> u32;
    pub fn nm_setting_802_1x_get_pac_file(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_password(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_password_raw(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    pub fn nm_setting_802_1x_get_password_raw_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase1_auth_flags(setting: *mut NMSetting8021x) -> NMSetting8021xAuthFlags;
    pub fn nm_setting_802_1x_get_phase1_fast_provisioning(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase1_peaplabel(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase1_peapver(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_altsubject_match(setting: *mut NMSetting8021x, i: u32) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_auth(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_autheap(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_ca_cert_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_ca_cert_password(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_ca_cert_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_phase2_ca_cert_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_ca_cert_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_ca_cert_uri(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_ca_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_client_cert_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_client_cert_password(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_client_cert_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_phase2_client_cert_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_client_cert_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_client_cert_uri(setting: *mut NMSetting8021x) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_domain_suffix_match(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_private_key_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    pub fn nm_setting_802_1x_get_phase2_private_key_format(setting: *mut NMSetting8021x) -> NMSetting8021xCKFormat;
    pub fn nm_setting_802_1x_get_phase2_private_key_password(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_private_key_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_phase2_private_key_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_private_key_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_802_1x_get_phase2_private_key_uri(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_phase2_subject_match(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_pin(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_pin_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_private_key_blob(setting: *mut NMSetting8021x) -> *mut glib::GBytes;
    pub fn nm_setting_802_1x_get_private_key_format(setting: *mut NMSetting8021x) -> NMSetting8021xCKFormat;
    pub fn nm_setting_802_1x_get_private_key_password(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_private_key_password_flags(setting: *mut NMSetting8021x) -> NMSettingSecretFlags;
    pub fn nm_setting_802_1x_get_private_key_path(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_private_key_scheme(setting: *mut NMSetting8021x) -> NMSetting8021xCKScheme;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_802_1x_get_private_key_uri(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_subject_match(setting: *mut NMSetting8021x) -> *const c_char;
    pub fn nm_setting_802_1x_get_system_ca_certs(setting: *mut NMSetting8021x) -> gboolean;
    pub fn nm_setting_802_1x_remove_altsubject_match(setting: *mut NMSetting8021x, i: u32);
    pub fn nm_setting_802_1x_remove_altsubject_match_by_value(setting: *mut NMSetting8021x, altsubject_match: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_remove_eap_method(setting: *mut NMSetting8021x, i: u32);
    pub fn nm_setting_802_1x_remove_eap_method_by_value(setting: *mut NMSetting8021x, eap: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_remove_phase2_altsubject_match(setting: *mut NMSetting8021x, i: u32);
    pub fn nm_setting_802_1x_remove_phase2_altsubject_match_by_value(setting: *mut NMSetting8021x, phase2_altsubject_match: *const c_char) -> gboolean;
    pub fn nm_setting_802_1x_set_ca_cert(setting: *mut NMSetting8021x, value: *const c_char, scheme: NMSetting8021xCKScheme, out_format: *mut NMSetting8021xCKFormat, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_setting_802_1x_set_client_cert(setting: *mut NMSetting8021x, value: *const c_char, scheme: NMSetting8021xCKScheme, out_format: *mut NMSetting8021xCKFormat, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_setting_802_1x_set_phase2_ca_cert(setting: *mut NMSetting8021x, value: *const c_char, scheme: NMSetting8021xCKScheme, out_format: *mut NMSetting8021xCKFormat, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_setting_802_1x_set_phase2_client_cert(setting: *mut NMSetting8021x, value: *const c_char, scheme: NMSetting8021xCKScheme, out_format: *mut NMSetting8021xCKFormat, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_setting_802_1x_set_phase2_private_key(setting: *mut NMSetting8021x, value: *const c_char, password: *const c_char, scheme: NMSetting8021xCKScheme, out_format: *mut NMSetting8021xCKFormat, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_setting_802_1x_set_private_key(setting: *mut NMSetting8021x, value: *const c_char, password: *const c_char, scheme: NMSetting8021xCKScheme, out_format: *mut NMSetting8021xCKFormat, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMSettingAdsl
    //=========================================================================
    pub fn nm_setting_adsl_get_type() -> GType;
    pub fn nm_setting_adsl_new() -> *mut NMSetting;
    pub fn nm_setting_adsl_get_encapsulation(setting: *mut NMSettingAdsl) -> *const c_char;
    pub fn nm_setting_adsl_get_password(setting: *mut NMSettingAdsl) -> *const c_char;
    pub fn nm_setting_adsl_get_password_flags(setting: *mut NMSettingAdsl) -> NMSettingSecretFlags;
    pub fn nm_setting_adsl_get_protocol(setting: *mut NMSettingAdsl) -> *const c_char;
    pub fn nm_setting_adsl_get_username(setting: *mut NMSettingAdsl) -> *const c_char;
    pub fn nm_setting_adsl_get_vci(setting: *mut NMSettingAdsl) -> u32;
    pub fn nm_setting_adsl_get_vpi(setting: *mut NMSettingAdsl) -> u32;

    //=========================================================================
    // NMSettingBluetooth
    //=========================================================================
    pub fn nm_setting_bluetooth_get_type() -> GType;
    pub fn nm_setting_bluetooth_new() -> *mut NMSetting;
    pub fn nm_setting_bluetooth_get_bdaddr(setting: *mut NMSettingBluetooth) -> *const c_char;
    pub fn nm_setting_bluetooth_get_connection_type(setting: *mut NMSettingBluetooth) -> *const c_char;

    //=========================================================================
    // NMSettingBond
    //=========================================================================
    pub fn nm_setting_bond_get_type() -> GType;
    pub fn nm_setting_bond_new() -> *mut NMSetting;
    pub fn nm_setting_bond_validate_option(name: *const c_char, value: *const c_char) -> gboolean;
    pub fn nm_setting_bond_add_option(setting: *mut NMSettingBond, name: *const c_char, value: *const c_char) -> gboolean;
    pub fn nm_setting_bond_get_num_options(setting: *mut NMSettingBond) -> u32;
    pub fn nm_setting_bond_get_option(setting: *mut NMSettingBond, idx: u32, out_name: *mut *const c_char, out_value: *mut *const c_char) -> gboolean;
    pub fn nm_setting_bond_get_option_by_name(setting: *mut NMSettingBond, name: *const c_char) -> *const c_char;
    pub fn nm_setting_bond_get_option_default(setting: *mut NMSettingBond, name: *const c_char) -> *const c_char;
    pub fn nm_setting_bond_get_valid_options(setting: *mut NMSettingBond) -> *mut *const c_char;
    pub fn nm_setting_bond_remove_option(setting: *mut NMSettingBond, name: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingBridge
    //=========================================================================
    pub fn nm_setting_bridge_get_type() -> GType;
    pub fn nm_setting_bridge_new() -> *mut NMSetting;
    pub fn nm_setting_bridge_get_ageing_time(setting: *mut NMSettingBridge) -> u32;
    pub fn nm_setting_bridge_get_forward_delay(setting: *mut NMSettingBridge) -> u16;
    pub fn nm_setting_bridge_get_hello_time(setting: *mut NMSettingBridge) -> u16;
    pub fn nm_setting_bridge_get_mac_address(setting: *mut NMSettingBridge) -> *const c_char;
    pub fn nm_setting_bridge_get_max_age(setting: *mut NMSettingBridge) -> u16;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_bridge_get_multicast_snooping(setting: *mut NMSettingBridge) -> gboolean;
    pub fn nm_setting_bridge_get_priority(setting: *mut NMSettingBridge) -> u16;
    pub fn nm_setting_bridge_get_stp(setting: *mut NMSettingBridge) -> gboolean;

    //=========================================================================
    // NMSettingBridgePort
    //=========================================================================
    pub fn nm_setting_bridge_port_get_type() -> GType;
    pub fn nm_setting_bridge_port_new() -> *mut NMSetting;
    pub fn nm_setting_bridge_port_get_hairpin_mode(setting: *mut NMSettingBridgePort) -> gboolean;
    pub fn nm_setting_bridge_port_get_path_cost(setting: *mut NMSettingBridgePort) -> u16;
    pub fn nm_setting_bridge_port_get_priority(setting: *mut NMSettingBridgePort) -> u16;

    //=========================================================================
    // NMSettingCdma
    //=========================================================================
    pub fn nm_setting_cdma_get_type() -> GType;
    pub fn nm_setting_cdma_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_cdma_get_mtu(setting: *mut NMSettingCdma) -> u32;
    pub fn nm_setting_cdma_get_number(setting: *mut NMSettingCdma) -> *const c_char;
    pub fn nm_setting_cdma_get_password(setting: *mut NMSettingCdma) -> *const c_char;
    pub fn nm_setting_cdma_get_password_flags(setting: *mut NMSettingCdma) -> NMSettingSecretFlags;
    pub fn nm_setting_cdma_get_username(setting: *mut NMSettingCdma) -> *const c_char;

    //=========================================================================
    // NMSettingConnection
    //=========================================================================
    pub fn nm_setting_connection_get_type() -> GType;
    pub fn nm_setting_connection_new() -> *mut NMSetting;
    pub fn nm_setting_connection_add_permission(setting: *mut NMSettingConnection, ptype: *const c_char, pitem: *const c_char, detail: *const c_char) -> gboolean;
    pub fn nm_setting_connection_add_secondary(setting: *mut NMSettingConnection, sec_uuid: *const c_char) -> gboolean;
    pub fn nm_setting_connection_get_autoconnect(setting: *mut NMSettingConnection) -> gboolean;
    pub fn nm_setting_connection_get_autoconnect_priority(setting: *mut NMSettingConnection) -> c_int;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_connection_get_autoconnect_retries(setting: *mut NMSettingConnection) -> c_int;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_connection_get_autoconnect_slaves(setting: *mut NMSettingConnection) -> NMSettingConnectionAutoconnectSlaves;
    pub fn nm_setting_connection_get_connection_type(setting: *mut NMSettingConnection) -> *const c_char;
    pub fn nm_setting_connection_get_gateway_ping_timeout(setting: *mut NMSettingConnection) -> u32;
    pub fn nm_setting_connection_get_id(setting: *mut NMSettingConnection) -> *const c_char;
    pub fn nm_setting_connection_get_interface_name(setting: *mut NMSettingConnection) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_connection_get_lldp(setting: *mut NMSettingConnection) -> NMSettingConnectionLldp;
    pub fn nm_setting_connection_get_master(setting: *mut NMSettingConnection) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_connection_get_metered(setting: *mut NMSettingConnection) -> NMMetered;
    pub fn nm_setting_connection_get_num_permissions(setting: *mut NMSettingConnection) -> u32;
    pub fn nm_setting_connection_get_num_secondaries(setting: *mut NMSettingConnection) -> u32;
    pub fn nm_setting_connection_get_permission(setting: *mut NMSettingConnection, idx: u32, out_ptype: *mut *const c_char, out_pitem: *mut *const c_char, out_detail: *mut *const c_char) -> gboolean;
    pub fn nm_setting_connection_get_read_only(setting: *mut NMSettingConnection) -> gboolean;
    pub fn nm_setting_connection_get_secondary(setting: *mut NMSettingConnection, idx: u32) -> *const c_char;
    pub fn nm_setting_connection_get_slave_type(setting: *mut NMSettingConnection) -> *const c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_setting_connection_get_stable_id(setting: *mut NMSettingConnection) -> *const c_char;
    pub fn nm_setting_connection_get_timestamp(setting: *mut NMSettingConnection) -> u64;
    pub fn nm_setting_connection_get_uuid(setting: *mut NMSettingConnection) -> *const c_char;
    pub fn nm_setting_connection_get_zone(setting: *mut NMSettingConnection) -> *const c_char;
    pub fn nm_setting_connection_is_slave_type(setting: *mut NMSettingConnection, type_: *const c_char) -> gboolean;
    pub fn nm_setting_connection_permissions_user_allowed(setting: *mut NMSettingConnection, uname: *const c_char) -> gboolean;
    pub fn nm_setting_connection_remove_permission(setting: *mut NMSettingConnection, idx: u32);
    pub fn nm_setting_connection_remove_permission_by_value(setting: *mut NMSettingConnection, ptype: *const c_char, pitem: *const c_char, detail: *const c_char) -> gboolean;
    pub fn nm_setting_connection_remove_secondary(setting: *mut NMSettingConnection, idx: u32);
    pub fn nm_setting_connection_remove_secondary_by_value(setting: *mut NMSettingConnection, sec_uuid: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingDcb
    //=========================================================================
    pub fn nm_setting_dcb_get_type() -> GType;
    pub fn nm_setting_dcb_new() -> *mut NMSetting;
    pub fn nm_setting_dcb_get_app_fcoe_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
    pub fn nm_setting_dcb_get_app_fcoe_mode(setting: *mut NMSettingDcb) -> *const c_char;
    pub fn nm_setting_dcb_get_app_fcoe_priority(setting: *mut NMSettingDcb) -> c_int;
    pub fn nm_setting_dcb_get_app_fip_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
    pub fn nm_setting_dcb_get_app_fip_priority(setting: *mut NMSettingDcb) -> c_int;
    pub fn nm_setting_dcb_get_app_iscsi_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
    pub fn nm_setting_dcb_get_app_iscsi_priority(setting: *mut NMSettingDcb) -> c_int;
    pub fn nm_setting_dcb_get_priority_bandwidth(setting: *mut NMSettingDcb, user_priority: c_uint) -> c_uint;
    pub fn nm_setting_dcb_get_priority_flow_control(setting: *mut NMSettingDcb, user_priority: c_uint) -> gboolean;
    pub fn nm_setting_dcb_get_priority_flow_control_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
    pub fn nm_setting_dcb_get_priority_group_bandwidth(setting: *mut NMSettingDcb, group_id: c_uint) -> c_uint;
    pub fn nm_setting_dcb_get_priority_group_flags(setting: *mut NMSettingDcb) -> NMSettingDcbFlags;
    pub fn nm_setting_dcb_get_priority_group_id(setting: *mut NMSettingDcb, user_priority: c_uint) -> c_uint;
    pub fn nm_setting_dcb_get_priority_strict_bandwidth(setting: *mut NMSettingDcb, user_priority: c_uint) -> gboolean;
    pub fn nm_setting_dcb_get_priority_traffic_class(setting: *mut NMSettingDcb, user_priority: c_uint) -> c_uint;
    pub fn nm_setting_dcb_set_priority_bandwidth(setting: *mut NMSettingDcb, user_priority: c_uint, bandwidth_percent: c_uint);
    pub fn nm_setting_dcb_set_priority_flow_control(setting: *mut NMSettingDcb, user_priority: c_uint, enabled: gboolean);
    pub fn nm_setting_dcb_set_priority_group_bandwidth(setting: *mut NMSettingDcb, group_id: c_uint, bandwidth_percent: c_uint);
    pub fn nm_setting_dcb_set_priority_group_id(setting: *mut NMSettingDcb, user_priority: c_uint, group_id: c_uint);
    pub fn nm_setting_dcb_set_priority_strict_bandwidth(setting: *mut NMSettingDcb, user_priority: c_uint, strict: gboolean);
    pub fn nm_setting_dcb_set_priority_traffic_class(setting: *mut NMSettingDcb, user_priority: c_uint, traffic_class: c_uint);

    //=========================================================================
    // NMSettingDummy
    //=========================================================================
    pub fn nm_setting_dummy_get_type() -> GType;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_dummy_new() -> *mut NMSetting;

    //=========================================================================
    // NMSettingGeneric
    //=========================================================================
    pub fn nm_setting_generic_get_type() -> GType;
    pub fn nm_setting_generic_new() -> *mut NMSetting;

    //=========================================================================
    // NMSettingGsm
    //=========================================================================
    pub fn nm_setting_gsm_get_type() -> GType;
    pub fn nm_setting_gsm_new() -> *mut NMSetting;
    pub fn nm_setting_gsm_get_apn(setting: *mut NMSettingGsm) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_gsm_get_device_id(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_home_only(setting: *mut NMSettingGsm) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_gsm_get_mtu(setting: *mut NMSettingGsm) -> u32;
    pub fn nm_setting_gsm_get_network_id(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_number(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_password(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_password_flags(setting: *mut NMSettingGsm) -> NMSettingSecretFlags;
    pub fn nm_setting_gsm_get_pin(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_pin_flags(setting: *mut NMSettingGsm) -> NMSettingSecretFlags;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_gsm_get_sim_id(setting: *mut NMSettingGsm) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_gsm_get_sim_operator_id(setting: *mut NMSettingGsm) -> *const c_char;
    pub fn nm_setting_gsm_get_username(setting: *mut NMSettingGsm) -> *const c_char;

    //=========================================================================
    // NMSettingIP4Config
    //=========================================================================
    pub fn nm_setting_ip4_config_get_type() -> GType;
    pub fn nm_setting_ip4_config_new() -> *mut NMSetting;
    pub fn nm_setting_ip4_config_get_dhcp_client_id(setting: *mut NMSettingIP4Config) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip4_config_get_dhcp_fqdn(setting: *mut NMSettingIP4Config) -> *const c_char;

    //=========================================================================
    // NMSettingIP6Config
    //=========================================================================
    pub fn nm_setting_ip6_config_get_type() -> GType;
    pub fn nm_setting_ip6_config_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip6_config_get_addr_gen_mode(setting: *mut NMSettingIP6Config) -> NMSettingIP6ConfigAddrGenMode;
    pub fn nm_setting_ip6_config_get_ip6_privacy(setting: *mut NMSettingIP6Config) -> NMSettingIP6ConfigPrivacy;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_setting_ip6_config_get_token(setting: *mut NMSettingIP6Config) -> *const c_char;

    //=========================================================================
    // NMSettingIPConfig
    //=========================================================================
    pub fn nm_setting_ip_config_get_type() -> GType;
    pub fn nm_setting_ip_config_add_address(setting: *mut NMSettingIPConfig, address: *mut NMIPAddress) -> gboolean;
    pub fn nm_setting_ip_config_add_dns(setting: *mut NMSettingIPConfig, dns: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_add_dns_option(setting: *mut NMSettingIPConfig, dns_option: *const c_char) -> gboolean;
    pub fn nm_setting_ip_config_add_dns_search(setting: *mut NMSettingIPConfig, dns_search: *const c_char) -> gboolean;
    pub fn nm_setting_ip_config_add_route(setting: *mut NMSettingIPConfig, route: *mut NMIPRoute) -> gboolean;
    pub fn nm_setting_ip_config_clear_addresses(setting: *mut NMSettingIPConfig);
    pub fn nm_setting_ip_config_clear_dns(setting: *mut NMSettingIPConfig);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_clear_dns_options(setting: *mut NMSettingIPConfig, is_set: gboolean);
    pub fn nm_setting_ip_config_clear_dns_searches(setting: *mut NMSettingIPConfig);
    pub fn nm_setting_ip_config_clear_routes(setting: *mut NMSettingIPConfig);
    pub fn nm_setting_ip_config_get_address(setting: *mut NMSettingIPConfig, idx: c_int) -> *mut NMIPAddress;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_get_dad_timeout(setting: *mut NMSettingIPConfig) -> c_int;
    pub fn nm_setting_ip_config_get_dhcp_hostname(setting: *mut NMSettingIPConfig) -> *const c_char;
    pub fn nm_setting_ip_config_get_dhcp_send_hostname(setting: *mut NMSettingIPConfig) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_get_dhcp_timeout(setting: *mut NMSettingIPConfig) -> c_int;
    pub fn nm_setting_ip_config_get_dns(setting: *mut NMSettingIPConfig, idx: c_int) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_get_dns_option(setting: *mut NMSettingIPConfig, idx: c_uint) -> *const c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_setting_ip_config_get_dns_priority(setting: *mut NMSettingIPConfig) -> c_int;
    pub fn nm_setting_ip_config_get_dns_search(setting: *mut NMSettingIPConfig, idx: c_int) -> *const c_char;
    pub fn nm_setting_ip_config_get_gateway(setting: *mut NMSettingIPConfig) -> *const c_char;
    pub fn nm_setting_ip_config_get_ignore_auto_dns(setting: *mut NMSettingIPConfig) -> gboolean;
    pub fn nm_setting_ip_config_get_ignore_auto_routes(setting: *mut NMSettingIPConfig) -> gboolean;
    pub fn nm_setting_ip_config_get_may_fail(setting: *mut NMSettingIPConfig) -> gboolean;
    pub fn nm_setting_ip_config_get_method(setting: *mut NMSettingIPConfig) -> *const c_char;
    pub fn nm_setting_ip_config_get_never_default(setting: *mut NMSettingIPConfig) -> gboolean;
    pub fn nm_setting_ip_config_get_num_addresses(setting: *mut NMSettingIPConfig) -> c_uint;
    pub fn nm_setting_ip_config_get_num_dns(setting: *mut NMSettingIPConfig) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_get_num_dns_options(setting: *mut NMSettingIPConfig) -> c_uint;
    pub fn nm_setting_ip_config_get_num_dns_searches(setting: *mut NMSettingIPConfig) -> c_uint;
    pub fn nm_setting_ip_config_get_num_routes(setting: *mut NMSettingIPConfig) -> c_uint;
    pub fn nm_setting_ip_config_get_route(setting: *mut NMSettingIPConfig, idx: c_int) -> *mut NMIPRoute;
    pub fn nm_setting_ip_config_get_route_metric(setting: *mut NMSettingIPConfig) -> i64;
    pub fn nm_setting_ip_config_has_dns_options(setting: *mut NMSettingIPConfig) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_next_valid_dns_option(setting: *mut NMSettingIPConfig, idx: c_uint) -> c_int;
    pub fn nm_setting_ip_config_remove_address(setting: *mut NMSettingIPConfig, idx: c_int);
    pub fn nm_setting_ip_config_remove_address_by_value(setting: *mut NMSettingIPConfig, address: *mut NMIPAddress) -> gboolean;
    pub fn nm_setting_ip_config_remove_dns(setting: *mut NMSettingIPConfig, idx: c_int);
    pub fn nm_setting_ip_config_remove_dns_by_value(setting: *mut NMSettingIPConfig, dns: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_remove_dns_option(setting: *mut NMSettingIPConfig, idx: c_int);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_config_remove_dns_option_by_value(setting: *mut NMSettingIPConfig, dns_option: *const c_char) -> gboolean;
    pub fn nm_setting_ip_config_remove_dns_search(setting: *mut NMSettingIPConfig, idx: c_int);
    pub fn nm_setting_ip_config_remove_dns_search_by_value(setting: *mut NMSettingIPConfig, dns_search: *const c_char) -> gboolean;
    pub fn nm_setting_ip_config_remove_route(setting: *mut NMSettingIPConfig, idx: c_int);
    pub fn nm_setting_ip_config_remove_route_by_value(setting: *mut NMSettingIPConfig, route: *mut NMIPRoute) -> gboolean;

    //=========================================================================
    // NMSettingIPTunnel
    //=========================================================================
    pub fn nm_setting_ip_tunnel_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_encapsulation_limit(setting: *mut NMSettingIPTunnel) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_flow_label(setting: *mut NMSettingIPTunnel) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_input_key(setting: *mut NMSettingIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_local(setting: *mut NMSettingIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_mode(setting: *mut NMSettingIPTunnel) -> NMIPTunnelMode;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_mtu(setting: *mut NMSettingIPTunnel) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_output_key(setting: *mut NMSettingIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_parent(setting: *mut NMSettingIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_path_mtu_discovery(setting: *mut NMSettingIPTunnel) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_remote(setting: *mut NMSettingIPTunnel) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_tos(setting: *mut NMSettingIPTunnel) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_ip_tunnel_get_ttl(setting: *mut NMSettingIPTunnel) -> c_uint;

    //=========================================================================
    // NMSettingInfiniband
    //=========================================================================
    pub fn nm_setting_infiniband_get_type() -> GType;
    pub fn nm_setting_infiniband_new() -> *mut NMSetting;
    pub fn nm_setting_infiniband_get_mac_address(setting: *mut NMSettingInfiniband) -> *const c_char;
    pub fn nm_setting_infiniband_get_mtu(setting: *mut NMSettingInfiniband) -> u32;
    pub fn nm_setting_infiniband_get_p_key(setting: *mut NMSettingInfiniband) -> c_int;
    pub fn nm_setting_infiniband_get_parent(setting: *mut NMSettingInfiniband) -> *const c_char;
    pub fn nm_setting_infiniband_get_transport_mode(setting: *mut NMSettingInfiniband) -> *const c_char;
    pub fn nm_setting_infiniband_get_virtual_interface_name(setting: *mut NMSettingInfiniband) -> *const c_char;

    //=========================================================================
    // NMSettingMacsec
    //=========================================================================
    pub fn nm_setting_macsec_get_type() -> GType;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_get_encrypt(setting: *mut NMSettingMacsec) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_get_mka_cak(setting: *mut NMSettingMacsec) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_get_mka_cak_flags(setting: *mut NMSettingMacsec) -> NMSettingSecretFlags;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_get_mka_ckn(setting: *mut NMSettingMacsec) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_get_mode(setting: *mut NMSettingMacsec) -> NMSettingMacsecMode;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_get_parent(setting: *mut NMSettingMacsec) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_get_port(setting: *mut NMSettingMacsec) -> c_int;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_macsec_get_validation(setting: *mut NMSettingMacsec) -> NMSettingMacsecValidation;

    //=========================================================================
    // NMSettingMacvlan
    //=========================================================================
    pub fn nm_setting_macvlan_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_macvlan_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_macvlan_get_mode(setting: *mut NMSettingMacvlan) -> NMSettingMacvlanMode;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_macvlan_get_parent(setting: *mut NMSettingMacvlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_macvlan_get_promiscuous(setting: *mut NMSettingMacvlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_macvlan_get_tap(setting: *mut NMSettingMacvlan) -> gboolean;

    //=========================================================================
    // NMSettingOlpcMesh
    //=========================================================================
    pub fn nm_setting_olpc_mesh_get_type() -> GType;
    pub fn nm_setting_olpc_mesh_new() -> *mut NMSetting;
    pub fn nm_setting_olpc_mesh_get_channel(setting: *mut NMSettingOlpcMesh) -> u32;
    pub fn nm_setting_olpc_mesh_get_dhcp_anycast_address(setting: *mut NMSettingOlpcMesh) -> *const c_char;
    pub fn nm_setting_olpc_mesh_get_ssid(setting: *mut NMSettingOlpcMesh) -> *mut glib::GBytes;

    //=========================================================================
    // NMSettingPpp
    //=========================================================================
    pub fn nm_setting_ppp_get_type() -> GType;
    pub fn nm_setting_ppp_new() -> *mut NMSetting;
    pub fn nm_setting_ppp_get_baud(setting: *mut NMSettingPpp) -> u32;
    pub fn nm_setting_ppp_get_crtscts(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_lcp_echo_failure(setting: *mut NMSettingPpp) -> u32;
    pub fn nm_setting_ppp_get_lcp_echo_interval(setting: *mut NMSettingPpp) -> u32;
    pub fn nm_setting_ppp_get_mppe_stateful(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_mru(setting: *mut NMSettingPpp) -> u32;
    pub fn nm_setting_ppp_get_mtu(setting: *mut NMSettingPpp) -> u32;
    pub fn nm_setting_ppp_get_no_vj_comp(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_noauth(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_nobsdcomp(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_nodeflate(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_refuse_chap(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_refuse_eap(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_refuse_mschap(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_refuse_mschapv2(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_refuse_pap(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_require_mppe(setting: *mut NMSettingPpp) -> gboolean;
    pub fn nm_setting_ppp_get_require_mppe_128(setting: *mut NMSettingPpp) -> gboolean;

    //=========================================================================
    // NMSettingPppoe
    //=========================================================================
    pub fn nm_setting_pppoe_get_type() -> GType;
    pub fn nm_setting_pppoe_new() -> *mut NMSetting;
    pub fn nm_setting_pppoe_get_password(setting: *mut NMSettingPppoe) -> *const c_char;
    pub fn nm_setting_pppoe_get_password_flags(setting: *mut NMSettingPppoe) -> NMSettingSecretFlags;
    pub fn nm_setting_pppoe_get_service(setting: *mut NMSettingPppoe) -> *const c_char;
    pub fn nm_setting_pppoe_get_username(setting: *mut NMSettingPppoe) -> *const c_char;

    //=========================================================================
    // NMSettingProxy
    //=========================================================================
    pub fn nm_setting_proxy_get_type() -> GType;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_proxy_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_proxy_get_browser_only(setting: *mut NMSettingProxy) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_proxy_get_method(setting: *mut NMSettingProxy) -> NMSettingProxyMethod;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_proxy_get_pac_script(setting: *mut NMSettingProxy) -> *const c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_setting_proxy_get_pac_url(setting: *mut NMSettingProxy) -> *const c_char;

    //=========================================================================
    // NMSettingSerial
    //=========================================================================
    pub fn nm_setting_serial_get_type() -> GType;
    pub fn nm_setting_serial_new() -> *mut NMSetting;
    pub fn nm_setting_serial_get_baud(setting: *mut NMSettingSerial) -> c_uint;
    pub fn nm_setting_serial_get_bits(setting: *mut NMSettingSerial) -> c_uint;
    pub fn nm_setting_serial_get_parity(setting: *mut NMSettingSerial) -> NMSettingSerialParity;
    pub fn nm_setting_serial_get_send_delay(setting: *mut NMSettingSerial) -> u64;
    pub fn nm_setting_serial_get_stopbits(setting: *mut NMSettingSerial) -> c_uint;

    //=========================================================================
    // NMSettingTeam
    //=========================================================================
    pub fn nm_setting_team_get_type() -> GType;
    pub fn nm_setting_team_new() -> *mut NMSetting;
    pub fn nm_setting_team_get_config(setting: *mut NMSettingTeam) -> *const c_char;

    //=========================================================================
    // NMSettingTeamPort
    //=========================================================================
    pub fn nm_setting_team_port_get_type() -> GType;
    pub fn nm_setting_team_port_new() -> *mut NMSetting;
    pub fn nm_setting_team_port_get_config(setting: *mut NMSettingTeamPort) -> *const c_char;

    //=========================================================================
    // NMSettingTun
    //=========================================================================
    pub fn nm_setting_tun_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_tun_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_tun_get_group(setting: *mut NMSettingTun) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_tun_get_mode(setting: *mut NMSettingTun) -> NMSettingTunMode;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_tun_get_multi_queue(setting: *mut NMSettingTun) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_tun_get_owner(setting: *mut NMSettingTun) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_tun_get_pi(setting: *mut NMSettingTun) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_tun_get_vnet_hdr(setting: *mut NMSettingTun) -> gboolean;

    //=========================================================================
    // NMSettingUser
    //=========================================================================
    pub fn nm_setting_user_get_type() -> GType;
    pub fn nm_setting_user_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_user_check_key(key: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_user_check_val(val: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_user_get_data(setting: *mut NMSettingUser, key: *const c_char) -> *const c_char;
    pub fn nm_setting_user_get_keys(setting: *mut NMSettingUser, out_len: *mut c_uint) -> *mut *mut c_char;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_setting_user_set_data(setting: *mut NMSettingUser, key: *const c_char, val: *const c_char, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMSettingVlan
    //=========================================================================
    pub fn nm_setting_vlan_get_type() -> GType;
    pub fn nm_setting_vlan_new() -> *mut NMSetting;
    pub fn nm_setting_vlan_add_priority(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, from: u32, to: u32) -> gboolean;
    pub fn nm_setting_vlan_add_priority_str(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, str: *const c_char) -> gboolean;
    pub fn nm_setting_vlan_clear_priorities(setting: *mut NMSettingVlan, map: NMVlanPriorityMap);
    pub fn nm_setting_vlan_get_flags(setting: *mut NMSettingVlan) -> u32;
    pub fn nm_setting_vlan_get_id(setting: *mut NMSettingVlan) -> u32;
    pub fn nm_setting_vlan_get_num_priorities(setting: *mut NMSettingVlan, map: NMVlanPriorityMap) -> i32;
    pub fn nm_setting_vlan_get_parent(setting: *mut NMSettingVlan) -> *const c_char;
    pub fn nm_setting_vlan_get_priority(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, idx: u32, out_from: *mut u32, out_to: *mut u32) -> gboolean;
    pub fn nm_setting_vlan_remove_priority(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, idx: u32);
    pub fn nm_setting_vlan_remove_priority_by_value(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, from: u32, to: u32) -> gboolean;
    pub fn nm_setting_vlan_remove_priority_str_by_value(setting: *mut NMSettingVlan, map: NMVlanPriorityMap, str: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingVpn
    //=========================================================================
    pub fn nm_setting_vpn_get_type() -> GType;
    pub fn nm_setting_vpn_new() -> *mut NMSetting;
    pub fn nm_setting_vpn_add_data_item(setting: *mut NMSettingVpn, key: *const c_char, item: *const c_char);
    pub fn nm_setting_vpn_add_secret(setting: *mut NMSettingVpn, key: *const c_char, secret: *const c_char);
    pub fn nm_setting_vpn_foreach_data_item(setting: *mut NMSettingVpn, func: NMVpnIterFunc, user_data: gpointer);
    pub fn nm_setting_vpn_foreach_secret(setting: *mut NMSettingVpn, func: NMVpnIterFunc, user_data: gpointer);
    pub fn nm_setting_vpn_get_data_item(setting: *mut NMSettingVpn, key: *const c_char) -> *const c_char;
    pub fn nm_setting_vpn_get_num_data_items(setting: *mut NMSettingVpn) -> u32;
    pub fn nm_setting_vpn_get_num_secrets(setting: *mut NMSettingVpn) -> u32;
    pub fn nm_setting_vpn_get_persistent(setting: *mut NMSettingVpn) -> gboolean;
    pub fn nm_setting_vpn_get_secret(setting: *mut NMSettingVpn, key: *const c_char) -> *const c_char;
    pub fn nm_setting_vpn_get_service_type(setting: *mut NMSettingVpn) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vpn_get_timeout(setting: *mut NMSettingVpn) -> u32;
    pub fn nm_setting_vpn_get_user_name(setting: *mut NMSettingVpn) -> *const c_char;
    pub fn nm_setting_vpn_remove_data_item(setting: *mut NMSettingVpn, key: *const c_char) -> gboolean;
    pub fn nm_setting_vpn_remove_secret(setting: *mut NMSettingVpn, key: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingVxlan
    //=========================================================================
    pub fn nm_setting_vxlan_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_new() -> *mut NMSetting;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_ageing(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_destination_port(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_id(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_l2_miss(setting: *mut NMSettingVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_l3_miss(setting: *mut NMSettingVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_learning(setting: *mut NMSettingVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_limit(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_local(setting: *mut NMSettingVxlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_parent(setting: *mut NMSettingVxlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_proxy(setting: *mut NMSettingVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_remote(setting: *mut NMSettingVxlan) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_rsc(setting: *mut NMSettingVxlan) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_source_port_max(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_source_port_min(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_tos(setting: *mut NMSettingVxlan) -> c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_vxlan_get_ttl(setting: *mut NMSettingVxlan) -> c_uint;

    //=========================================================================
    // NMSettingWimax
    //=========================================================================
    pub fn nm_setting_wimax_get_type() -> GType;
    pub fn nm_setting_wimax_new() -> *mut NMSetting;
    pub fn nm_setting_wimax_get_mac_address(setting: *mut NMSettingWimax) -> *const c_char;
    pub fn nm_setting_wimax_get_network_name(setting: *mut NMSettingWimax) -> *const c_char;

    //=========================================================================
    // NMSettingWired
    //=========================================================================
    pub fn nm_setting_wired_get_type() -> GType;
    pub fn nm_setting_wired_new() -> *mut NMSetting;
    pub fn nm_setting_wired_add_mac_blacklist_item(setting: *mut NMSettingWired, mac: *const c_char) -> gboolean;
    pub fn nm_setting_wired_add_s390_option(setting: *mut NMSettingWired, key: *const c_char, value: *const c_char) -> gboolean;
    pub fn nm_setting_wired_clear_mac_blacklist_items(setting: *mut NMSettingWired);
    pub fn nm_setting_wired_get_auto_negotiate(setting: *mut NMSettingWired) -> gboolean;
    pub fn nm_setting_wired_get_cloned_mac_address(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_get_duplex(setting: *mut NMSettingWired) -> *const c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_setting_wired_get_generate_mac_address_mask(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_get_mac_address(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_get_mac_address_blacklist(setting: *mut NMSettingWired) -> *const *const c_char;
    pub fn nm_setting_wired_get_mac_blacklist_item(setting: *mut NMSettingWired, idx: u32) -> *const c_char;
    pub fn nm_setting_wired_get_mtu(setting: *mut NMSettingWired) -> u32;
    pub fn nm_setting_wired_get_num_mac_blacklist_items(setting: *mut NMSettingWired) -> u32;
    pub fn nm_setting_wired_get_num_s390_options(setting: *mut NMSettingWired) -> u32;
    pub fn nm_setting_wired_get_port(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_get_s390_nettype(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_get_s390_option(setting: *mut NMSettingWired, idx: u32, out_key: *mut *const c_char, out_value: *mut *const c_char) -> gboolean;
    pub fn nm_setting_wired_get_s390_option_by_key(setting: *mut NMSettingWired, key: *const c_char) -> *const c_char;
    pub fn nm_setting_wired_get_s390_subchannels(setting: *mut NMSettingWired) -> *const *const c_char;
    pub fn nm_setting_wired_get_speed(setting: *mut NMSettingWired) -> u32;
    pub fn nm_setting_wired_get_valid_s390_options(setting: *mut NMSettingWired) -> *mut *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_wired_get_wake_on_lan(setting: *mut NMSettingWired) -> NMSettingWiredWakeOnLan;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_wired_get_wake_on_lan_password(setting: *mut NMSettingWired) -> *const c_char;
    pub fn nm_setting_wired_remove_mac_blacklist_item(setting: *mut NMSettingWired, idx: u32);
    pub fn nm_setting_wired_remove_mac_blacklist_item_by_value(setting: *mut NMSettingWired, mac: *const c_char) -> gboolean;
    pub fn nm_setting_wired_remove_s390_option(setting: *mut NMSettingWired, key: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingWireless
    //=========================================================================
    pub fn nm_setting_wireless_get_type() -> GType;
    pub fn nm_setting_wireless_new() -> *mut NMSetting;
    pub fn nm_setting_wireless_add_mac_blacklist_item(setting: *mut NMSettingWireless, mac: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_add_seen_bssid(setting: *mut NMSettingWireless, bssid: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_ap_security_compatible(s_wireless: *mut NMSettingWireless, s_wireless_sec: *mut NMSettingWirelessSecurity, ap_flags: NM80211ApFlags, ap_wpa: NM80211ApSecurityFlags, ap_rsn: NM80211ApSecurityFlags, ap_mode: NM80211Mode) -> gboolean;
    pub fn nm_setting_wireless_clear_mac_blacklist_items(setting: *mut NMSettingWireless);
    pub fn nm_setting_wireless_get_band(setting: *mut NMSettingWireless) -> *const c_char;
    pub fn nm_setting_wireless_get_bssid(setting: *mut NMSettingWireless) -> *const c_char;
    pub fn nm_setting_wireless_get_channel(setting: *mut NMSettingWireless) -> u32;
    pub fn nm_setting_wireless_get_cloned_mac_address(setting: *mut NMSettingWireless) -> *const c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_setting_wireless_get_generate_mac_address_mask(setting: *mut NMSettingWireless) -> *const c_char;
    pub fn nm_setting_wireless_get_hidden(setting: *mut NMSettingWireless) -> gboolean;
    pub fn nm_setting_wireless_get_mac_address(setting: *mut NMSettingWireless) -> *const c_char;
    pub fn nm_setting_wireless_get_mac_address_blacklist(setting: *mut NMSettingWireless) -> *const *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_wireless_get_mac_address_randomization(setting: *mut NMSettingWireless) -> NMSettingMacRandomization;
    pub fn nm_setting_wireless_get_mac_blacklist_item(setting: *mut NMSettingWireless, idx: u32) -> *const c_char;
    pub fn nm_setting_wireless_get_mode(setting: *mut NMSettingWireless) -> *const c_char;
    pub fn nm_setting_wireless_get_mtu(setting: *mut NMSettingWireless) -> u32;
    pub fn nm_setting_wireless_get_num_mac_blacklist_items(setting: *mut NMSettingWireless) -> u32;
    pub fn nm_setting_wireless_get_num_seen_bssids(setting: *mut NMSettingWireless) -> u32;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_setting_wireless_get_powersave(setting: *mut NMSettingWireless) -> u32;
    pub fn nm_setting_wireless_get_rate(setting: *mut NMSettingWireless) -> u32;
    pub fn nm_setting_wireless_get_seen_bssid(setting: *mut NMSettingWireless, i: u32) -> *const c_char;
    pub fn nm_setting_wireless_get_ssid(setting: *mut NMSettingWireless) -> *mut glib::GBytes;
    pub fn nm_setting_wireless_get_tx_power(setting: *mut NMSettingWireless) -> u32;
    pub fn nm_setting_wireless_remove_mac_blacklist_item(setting: *mut NMSettingWireless, idx: u32);
    pub fn nm_setting_wireless_remove_mac_blacklist_item_by_value(setting: *mut NMSettingWireless, mac: *const c_char) -> gboolean;

    //=========================================================================
    // NMSettingWirelessSecurity
    //=========================================================================
    pub fn nm_setting_wireless_security_get_type() -> GType;
    pub fn nm_setting_wireless_security_new() -> *mut NMSetting;
    pub fn nm_setting_wireless_security_add_group(setting: *mut NMSettingWirelessSecurity, group: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_add_pairwise(setting: *mut NMSettingWirelessSecurity, pairwise: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_add_proto(setting: *mut NMSettingWirelessSecurity, proto: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_clear_groups(setting: *mut NMSettingWirelessSecurity);
    pub fn nm_setting_wireless_security_clear_pairwise(setting: *mut NMSettingWirelessSecurity);
    pub fn nm_setting_wireless_security_clear_protos(setting: *mut NMSettingWirelessSecurity);
    pub fn nm_setting_wireless_security_get_auth_alg(setting: *mut NMSettingWirelessSecurity) -> *const c_char;
    pub fn nm_setting_wireless_security_get_group(setting: *mut NMSettingWirelessSecurity, i: u32) -> *const c_char;
    pub fn nm_setting_wireless_security_get_key_mgmt(setting: *mut NMSettingWirelessSecurity) -> *const c_char;
    pub fn nm_setting_wireless_security_get_leap_password(setting: *mut NMSettingWirelessSecurity) -> *const c_char;
    pub fn nm_setting_wireless_security_get_leap_password_flags(setting: *mut NMSettingWirelessSecurity) -> NMSettingSecretFlags;
    pub fn nm_setting_wireless_security_get_leap_username(setting: *mut NMSettingWirelessSecurity) -> *const c_char;
    pub fn nm_setting_wireless_security_get_num_groups(setting: *mut NMSettingWirelessSecurity) -> u32;
    pub fn nm_setting_wireless_security_get_num_pairwise(setting: *mut NMSettingWirelessSecurity) -> u32;
    pub fn nm_setting_wireless_security_get_num_protos(setting: *mut NMSettingWirelessSecurity) -> u32;
    pub fn nm_setting_wireless_security_get_pairwise(setting: *mut NMSettingWirelessSecurity, i: u32) -> *const c_char;
    pub fn nm_setting_wireless_security_get_proto(setting: *mut NMSettingWirelessSecurity, i: u32) -> *const c_char;
    pub fn nm_setting_wireless_security_get_psk(setting: *mut NMSettingWirelessSecurity) -> *const c_char;
    pub fn nm_setting_wireless_security_get_psk_flags(setting: *mut NMSettingWirelessSecurity) -> NMSettingSecretFlags;
    pub fn nm_setting_wireless_security_get_wep_key(setting: *mut NMSettingWirelessSecurity, idx: u32) -> *const c_char;
    pub fn nm_setting_wireless_security_get_wep_key_flags(setting: *mut NMSettingWirelessSecurity) -> NMSettingSecretFlags;
    pub fn nm_setting_wireless_security_get_wep_key_type(setting: *mut NMSettingWirelessSecurity) -> NMWepKeyType;
    pub fn nm_setting_wireless_security_get_wep_tx_keyidx(setting: *mut NMSettingWirelessSecurity) -> u32;
    pub fn nm_setting_wireless_security_remove_group(setting: *mut NMSettingWirelessSecurity, i: u32);
    pub fn nm_setting_wireless_security_remove_group_by_value(setting: *mut NMSettingWirelessSecurity, group: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_remove_pairwise(setting: *mut NMSettingWirelessSecurity, i: u32);
    pub fn nm_setting_wireless_security_remove_pairwise_by_value(setting: *mut NMSettingWirelessSecurity, pairwise: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_remove_proto(setting: *mut NMSettingWirelessSecurity, i: u32);
    pub fn nm_setting_wireless_security_remove_proto_by_value(setting: *mut NMSettingWirelessSecurity, proto: *const c_char) -> gboolean;
    pub fn nm_setting_wireless_security_set_wep_key(setting: *mut NMSettingWirelessSecurity, idx: u32, key: *const c_char);

    //=========================================================================
    // NMSimpleConnection
    //=========================================================================
    pub fn nm_simple_connection_get_type() -> GType;
    pub fn nm_simple_connection_new() -> *mut NMConnection;
    pub fn nm_simple_connection_new_clone(connection: *mut NMConnection) -> *mut NMConnection;
    pub fn nm_simple_connection_new_from_dbus(dict: *mut glib::GVariant, error: *mut *mut glib::GError) -> *mut NMConnection;

    //=========================================================================
    // NMVpnConnection
    //=========================================================================
    pub fn nm_vpn_connection_get_type() -> GType;
    pub fn nm_vpn_connection_get_banner(vpn: *mut NMVpnConnection) -> *const c_char;
    pub fn nm_vpn_connection_get_vpn_state(vpn: *mut NMVpnConnection) -> NMVpnConnectionState;

    //=========================================================================
    // NMVpnPluginInfo
    //=========================================================================
    pub fn nm_vpn_plugin_info_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_new_from_file(filename: *const c_char, error: *mut *mut glib::GError) -> *mut NMVpnPluginInfo;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_plugin_info_new_search_file(name: *const c_char, service: *const c_char) -> *mut NMVpnPluginInfo;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_new_with_data(filename: *const c_char, keyfile: *mut glib::GKeyFile, error: *mut *mut glib::GError) -> *mut NMVpnPluginInfo;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_list_add(list: *mut *mut glib::GSList, plugin_info: *mut NMVpnPluginInfo, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_list_find_by_filename(list: *mut glib::GSList, filename: *const c_char) -> *mut NMVpnPluginInfo;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_list_find_by_name(list: *mut glib::GSList, name: *const c_char) -> *mut NMVpnPluginInfo;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_list_find_by_service(list: *mut glib::GSList, service: *const c_char) -> *mut NMVpnPluginInfo;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_plugin_info_list_find_service_type(list: *mut glib::GSList, name: *const c_char) -> *mut c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_plugin_info_list_get_service_types(list: *mut glib::GSList, only_existing: gboolean, with_abbreviations: gboolean) -> *mut *mut c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_list_load() -> *mut glib::GSList;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_list_remove(list: *mut *mut glib::GSList, plugin_info: *mut NMVpnPluginInfo) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_validate_filename(filename: *const c_char) -> gboolean;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_plugin_info_get_aliases(self_: *mut NMVpnPluginInfo) -> *mut *mut c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_plugin_info_get_auth_dialog(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_get_editor_plugin(self_: *mut NMVpnPluginInfo) -> *mut NMVpnEditorPlugin;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_get_filename(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_get_name(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_get_plugin(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_get_program(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_plugin_info_get_service(self_: *mut NMVpnPluginInfo) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_load_editor_plugin(self_: *mut NMVpnPluginInfo, error: *mut *mut glib::GError) -> *mut NMVpnEditorPlugin;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_lookup_property(self_: *mut NMVpnPluginInfo, group: *const c_char, key: *const c_char) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_set_editor_plugin(self_: *mut NMVpnPluginInfo, plugin: *mut NMVpnEditorPlugin);
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_plugin_info_supports_hints(self_: *mut NMVpnPluginInfo) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_plugin_info_supports_multiple(self_: *mut NMVpnPluginInfo) -> gboolean;

    //=========================================================================
    // NMVpnPluginOld
    //=========================================================================
    pub fn nm_vpn_plugin_old_get_type() -> GType;
    pub fn nm_vpn_plugin_old_get_secret_flags(data: *mut glib::GHashTable, secret_name: *const c_char, out_flags: *mut NMSettingSecretFlags) -> gboolean;
    pub fn nm_vpn_plugin_old_read_vpn_details(fd: c_int, out_data: *mut *mut glib::GHashTable, out_secrets: *mut *mut glib::GHashTable) -> gboolean;
    pub fn nm_vpn_plugin_old_disconnect(plugin: *mut NMVpnPluginOld, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_vpn_plugin_old_failure(plugin: *mut NMVpnPluginOld, reason: NMVpnPluginFailure);
    pub fn nm_vpn_plugin_old_get_connection(plugin: *mut NMVpnPluginOld) -> *mut gio::GDBusConnection;
    pub fn nm_vpn_plugin_old_get_state(plugin: *mut NMVpnPluginOld) -> NMVpnServiceState;
    pub fn nm_vpn_plugin_old_secrets_required(plugin: *mut NMVpnPluginOld, message: *const c_char, hints: *mut *const c_char);
    pub fn nm_vpn_plugin_old_set_config(plugin: *mut NMVpnPluginOld, config: *mut glib::GVariant);
    pub fn nm_vpn_plugin_old_set_ip4_config(plugin: *mut NMVpnPluginOld, ip4_config: *mut glib::GVariant);
    pub fn nm_vpn_plugin_old_set_ip6_config(plugin: *mut NMVpnPluginOld, ip6_config: *mut glib::GVariant);
    pub fn nm_vpn_plugin_old_set_login_banner(plugin: *mut NMVpnPluginOld, banner: *const c_char);
    pub fn nm_vpn_plugin_old_set_state(plugin: *mut NMVpnPluginOld, state: NMVpnServiceState);

    //=========================================================================
    // NMVpnServicePlugin
    //=========================================================================
    pub fn nm_vpn_service_plugin_get_type() -> GType;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_service_plugin_get_secret_flags(data: *mut glib::GHashTable, secret_name: *const c_char, out_flags: *mut NMSettingSecretFlags) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_service_plugin_read_vpn_details(fd: c_int, out_data: *mut *mut glib::GHashTable, out_secrets: *mut *mut glib::GHashTable) -> gboolean;
    pub fn nm_vpn_service_plugin_disconnect(plugin: *mut NMVpnServicePlugin, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_vpn_service_plugin_failure(plugin: *mut NMVpnServicePlugin, reason: NMVpnPluginFailure);
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_service_plugin_get_connection(plugin: *mut NMVpnServicePlugin) -> *mut gio::GDBusConnection;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_service_plugin_secrets_required(plugin: *mut NMVpnServicePlugin, message: *const c_char, hints: *mut *const c_char);
    pub fn nm_vpn_service_plugin_set_config(plugin: *mut NMVpnServicePlugin, config: *mut glib::GVariant);
    pub fn nm_vpn_service_plugin_set_ip4_config(plugin: *mut NMVpnServicePlugin, ip4_config: *mut glib::GVariant);
    pub fn nm_vpn_service_plugin_set_ip6_config(plugin: *mut NMVpnServicePlugin, ip6_config: *mut glib::GVariant);
    pub fn nm_vpn_service_plugin_set_login_banner(plugin: *mut NMVpnServicePlugin, banner: *const c_char);

    //=========================================================================
    // NMWimaxNsp
    //=========================================================================
    pub fn nm_wimax_nsp_get_type() -> GType;
    pub fn nm_wimax_nsp_connection_valid(nsp: *mut NMWimaxNsp, connection: *mut NMConnection) -> gboolean;
    pub fn nm_wimax_nsp_filter_connections(nsp: *mut NMWimaxNsp, connections: *const glib::GPtrArray) -> *mut glib::GPtrArray;
    pub fn nm_wimax_nsp_get_name(nsp: *mut NMWimaxNsp) -> *const c_char;
    pub fn nm_wimax_nsp_get_network_type(nsp: *mut NMWimaxNsp) -> NMWimaxNspNetworkType;
    pub fn nm_wimax_nsp_get_signal_quality(nsp: *mut NMWimaxNsp) -> u32;

    //=========================================================================
    // NMConnection
    //=========================================================================
    pub fn nm_connection_get_type() -> GType;
    pub fn nm_connection_add_setting(connection: *mut NMConnection, setting: *mut NMSetting);
    pub fn nm_connection_clear_secrets(connection: *mut NMConnection);
    pub fn nm_connection_clear_secrets_with_flags(connection: *mut NMConnection, func: NMSettingClearSecretsWithFlagsFn, user_data: gpointer);
    pub fn nm_connection_clear_settings(connection: *mut NMConnection);
    pub fn nm_connection_compare(a: *mut NMConnection, b: *mut NMConnection, flags: NMSettingCompareFlags) -> gboolean;
    pub fn nm_connection_diff(a: *mut NMConnection, b: *mut NMConnection, flags: NMSettingCompareFlags, out_settings: *mut *mut glib::GHashTable) -> gboolean;
    pub fn nm_connection_dump(connection: *mut NMConnection);
    pub fn nm_connection_for_each_setting_value(connection: *mut NMConnection, func: NMSettingValueIterFn, user_data: gpointer);
    pub fn nm_connection_get_connection_type(connection: *mut NMConnection) -> *const c_char;
    pub fn nm_connection_get_id(connection: *mut NMConnection) -> *const c_char;
    pub fn nm_connection_get_interface_name(connection: *mut NMConnection) -> *const c_char;
    pub fn nm_connection_get_path(connection: *mut NMConnection) -> *const c_char;
    pub fn nm_connection_get_setting(connection: *mut NMConnection, setting_type: GType) -> *mut NMSetting;
    pub fn nm_connection_get_setting_802_1x(connection: *mut NMConnection) -> *mut NMSetting8021x;
    pub fn nm_connection_get_setting_adsl(connection: *mut NMConnection) -> *mut NMSettingAdsl;
    pub fn nm_connection_get_setting_bluetooth(connection: *mut NMConnection) -> *mut NMSettingBluetooth;
    pub fn nm_connection_get_setting_bond(connection: *mut NMConnection) -> *mut NMSettingBond;
    pub fn nm_connection_get_setting_bridge(connection: *mut NMConnection) -> *mut NMSettingBridge;
    pub fn nm_connection_get_setting_bridge_port(connection: *mut NMConnection) -> *mut NMSettingBridgePort;
    pub fn nm_connection_get_setting_by_name(connection: *mut NMConnection, name: *const c_char) -> *mut NMSetting;
    pub fn nm_connection_get_setting_cdma(connection: *mut NMConnection) -> *mut NMSettingCdma;
    pub fn nm_connection_get_setting_connection(connection: *mut NMConnection) -> *mut NMSettingConnection;
    pub fn nm_connection_get_setting_dcb(connection: *mut NMConnection) -> *mut NMSettingDcb;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_connection_get_setting_dummy(connection: *mut NMConnection) -> *mut NMSettingDummy;
    pub fn nm_connection_get_setting_generic(connection: *mut NMConnection) -> *mut NMSettingGeneric;
    pub fn nm_connection_get_setting_gsm(connection: *mut NMConnection) -> *mut NMSettingGsm;
    pub fn nm_connection_get_setting_infiniband(connection: *mut NMConnection) -> *mut NMSettingInfiniband;
    pub fn nm_connection_get_setting_ip4_config(connection: *mut NMConnection) -> *mut NMSettingIP4Config;
    pub fn nm_connection_get_setting_ip6_config(connection: *mut NMConnection) -> *mut NMSettingIP6Config;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_connection_get_setting_ip_tunnel(connection: *mut NMConnection) -> *mut NMSettingIPTunnel;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_connection_get_setting_macsec(connection: *mut NMConnection) -> *mut NMSettingMacsec;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_connection_get_setting_macvlan(connection: *mut NMConnection) -> *mut NMSettingMacvlan;
    pub fn nm_connection_get_setting_olpc_mesh(connection: *mut NMConnection) -> *mut NMSettingOlpcMesh;
    pub fn nm_connection_get_setting_ppp(connection: *mut NMConnection) -> *mut NMSettingPpp;
    pub fn nm_connection_get_setting_pppoe(connection: *mut NMConnection) -> *mut NMSettingPppoe;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_connection_get_setting_proxy(connection: *mut NMConnection) -> *mut NMSettingProxy;
    pub fn nm_connection_get_setting_serial(connection: *mut NMConnection) -> *mut NMSettingSerial;
    pub fn nm_connection_get_setting_team(connection: *mut NMConnection) -> *mut NMSettingTeam;
    pub fn nm_connection_get_setting_team_port(connection: *mut NMConnection) -> *mut NMSettingTeamPort;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_connection_get_setting_tun(connection: *mut NMConnection) -> *mut NMSettingTun;
    pub fn nm_connection_get_setting_vlan(connection: *mut NMConnection) -> *mut NMSettingVlan;
    pub fn nm_connection_get_setting_vpn(connection: *mut NMConnection) -> *mut NMSettingVpn;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_connection_get_setting_vxlan(connection: *mut NMConnection) -> *mut NMSettingVxlan;
    pub fn nm_connection_get_setting_wimax(connection: *mut NMConnection) -> *mut NMSettingWimax;
    pub fn nm_connection_get_setting_wired(connection: *mut NMConnection) -> *mut NMSettingWired;
    pub fn nm_connection_get_setting_wireless(connection: *mut NMConnection) -> *mut NMSettingWireless;
    pub fn nm_connection_get_setting_wireless_security(connection: *mut NMConnection) -> *mut NMSettingWirelessSecurity;
    pub fn nm_connection_get_uuid(connection: *mut NMConnection) -> *const c_char;
    pub fn nm_connection_get_virtual_device_description(connection: *mut NMConnection) -> *mut c_char;
    pub fn nm_connection_is_type(connection: *mut NMConnection, type_: *const c_char) -> gboolean;
    pub fn nm_connection_is_virtual(connection: *mut NMConnection) -> gboolean;
    pub fn nm_connection_need_secrets(connection: *mut NMConnection, hints: *mut *mut glib::GPtrArray) -> *const c_char;
    pub fn nm_connection_normalize(connection: *mut NMConnection, parameters: *mut glib::GHashTable, modified: *mut gboolean, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_connection_remove_setting(connection: *mut NMConnection, setting_type: GType);
    pub fn nm_connection_replace_settings(connection: *mut NMConnection, new_settings: *mut glib::GVariant, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_connection_replace_settings_from_connection(connection: *mut NMConnection, new_connection: *mut NMConnection);
    pub fn nm_connection_set_path(connection: *mut NMConnection, path: *const c_char);
    pub fn nm_connection_to_dbus(connection: *mut NMConnection, flags: NMConnectionSerializationFlags) -> *mut glib::GVariant;
    pub fn nm_connection_update_secrets(connection: *mut NMConnection, setting_name: *const c_char, secrets: *mut glib::GVariant, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_connection_verify(connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_connection_verify_secrets(connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMVpnEditor
    //=========================================================================
    pub fn nm_vpn_editor_get_type() -> GType;
    pub fn nm_vpn_editor_get_widget(editor: *mut NMVpnEditor) -> *mut gobject::GObject;
    pub fn nm_vpn_editor_update_connection(editor: *mut NMVpnEditor, connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;

    //=========================================================================
    // NMVpnEditorPlugin
    //=========================================================================
    pub fn nm_vpn_editor_plugin_get_type() -> GType;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_editor_plugin_load(plugin_name: *const c_char, check_service: *const c_char, error: *mut *mut glib::GError) -> *mut NMVpnEditorPlugin;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_vpn_editor_plugin_load_from_file(plugin_name: *const c_char, check_service: *const c_char, check_owner: c_int, check_file: NMUtilsCheckFilePredicate, user_data: gpointer, error: *mut *mut glib::GError) -> *mut NMVpnEditorPlugin;
    pub fn nm_vpn_editor_plugin_export(plugin: *mut NMVpnEditorPlugin, path: *const c_char, connection: *mut NMConnection, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_vpn_editor_plugin_get_capabilities(plugin: *mut NMVpnEditorPlugin) -> NMVpnEditorPluginCapability;
    pub fn nm_vpn_editor_plugin_get_editor(plugin: *mut NMVpnEditorPlugin, connection: *mut NMConnection, error: *mut *mut glib::GError) -> *mut NMVpnEditor;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_editor_plugin_get_plugin_info(plugin: *mut NMVpnEditorPlugin) -> *mut _NMVpnPluginInfo;
    pub fn nm_vpn_editor_plugin_get_suggested_filename(plugin: *mut NMVpnEditorPlugin, connection: *mut NMConnection) -> *mut c_char;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_editor_plugin_get_vt(plugin: *mut NMVpnEditorPlugin, vt: *mut NMVpnEditorPluginVT, vt_size: size_t) -> size_t;
    pub fn nm_vpn_editor_plugin_import(plugin: *mut NMVpnEditorPlugin, path: *const c_char, error: *mut *mut glib::GError) -> *mut NMConnection;
    #[cfg(any(feature = "v1_4", feature = "dox"))]
    pub fn nm_vpn_editor_plugin_set_plugin_info(plugin: *mut NMVpnEditorPlugin, plugin_info: *mut _NMVpnPluginInfo);

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn nm_utils_ap_mode_security_valid(type_: NMUtilsSecurityType, wifi_caps: NMDeviceWifiCapabilities) -> gboolean;
    pub fn nm_utils_bin2hexstr(src: gconstpointer, len: size_t, final_len: c_int) -> *mut c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_utils_bond_mode_int_to_string(mode: c_int) -> *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_utils_bond_mode_string_to_int(mode: *const c_char) -> c_int;
    pub fn nm_utils_check_virtual_device_compatibility(virtual_type: GType, other_type: GType) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_utils_enum_from_str(type_: GType, str: *const c_char, out_value: *mut c_int, err_token: *mut *mut c_char) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_utils_enum_get_values(type_: GType, from: c_int, to: c_int) -> *mut *const c_char;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_utils_enum_to_str(type_: GType, value: c_int) -> *mut c_char;
    pub fn nm_utils_escape_ssid(ssid: *mut u8, len: size_t) -> *const c_char;
    pub fn nm_utils_file_is_certificate(filename: *const c_char) -> gboolean;
    pub fn nm_utils_file_is_pkcs12(filename: *const c_char) -> gboolean;
    pub fn nm_utils_file_is_private_key(filename: *const c_char, out_encrypted: *mut gboolean) -> gboolean;
    pub fn nm_utils_file_search_in_paths(progname: *const c_char, try_first: *const c_char, paths: *const *const c_char, file_test_flags: glib::GFileTest, predicate: NMUtilsFileSearchInPathsPredicate, user_data: gpointer, error: *mut *mut glib::GError) -> *const c_char;
    pub fn nm_utils_format_variant_attributes(attributes: *mut glib::GHashTable, attr_separator: c_char, key_value_separator: c_char) -> *mut c_char;
    pub fn nm_utils_hexstr2bin(hex: *const c_char) -> *mut glib::GBytes;
    pub fn nm_utils_hwaddr_atoba(asc: *const c_char, length: size_t) -> *mut glib::GByteArray;
    pub fn nm_utils_hwaddr_aton(asc: *const c_char, buffer: gpointer, length: size_t) -> *mut u8;
    pub fn nm_utils_hwaddr_canonical(asc: *const c_char, length: ssize_t) -> *mut c_char;
    pub fn nm_utils_hwaddr_len(type_: c_int) -> size_t;
    pub fn nm_utils_hwaddr_matches(hwaddr1: gconstpointer, hwaddr1_len: ssize_t, hwaddr2: gconstpointer, hwaddr2_len: ssize_t) -> gboolean;
    pub fn nm_utils_hwaddr_ntoa(addr: gconstpointer, length: size_t) -> *mut c_char;
    pub fn nm_utils_hwaddr_valid(asc: *const c_char, length: ssize_t) -> gboolean;
    pub fn nm_utils_iface_valid_name(name: *const c_char) -> gboolean;
    pub fn nm_utils_inet6_ntop(in6addr: *const in6_addr, dst: *mut c_char) -> *const c_char;
    pub fn nm_utils_ip4_addresses_from_variant(value: *mut glib::GVariant, out_gateway: *mut *mut c_char) -> *mut glib::GPtrArray;
    pub fn nm_utils_ip4_addresses_to_variant(addresses: *mut glib::GPtrArray, gateway: *const c_char) -> *mut glib::GVariant;
    pub fn nm_utils_ip4_dns_from_variant(value: *mut glib::GVariant) -> *mut *mut c_char;
    pub fn nm_utils_ip4_dns_to_variant(dns: *mut *mut c_char) -> *mut glib::GVariant;
    pub fn nm_utils_ip4_get_default_prefix(ip: u32) -> u32;
    pub fn nm_utils_ip4_netmask_to_prefix(netmask: u32) -> u32;
    pub fn nm_utils_ip4_prefix_to_netmask(prefix: u32) -> u32;
    pub fn nm_utils_ip4_routes_from_variant(value: *mut glib::GVariant) -> *mut glib::GPtrArray;
    pub fn nm_utils_ip4_routes_to_variant(routes: *mut glib::GPtrArray) -> *mut glib::GVariant;
    pub fn nm_utils_ip6_addresses_from_variant(value: *mut glib::GVariant, out_gateway: *mut *mut c_char) -> *mut glib::GPtrArray;
    pub fn nm_utils_ip6_addresses_to_variant(addresses: *mut glib::GPtrArray, gateway: *const c_char) -> *mut glib::GVariant;
    pub fn nm_utils_ip6_dns_from_variant(value: *mut glib::GVariant) -> *mut *mut c_char;
    pub fn nm_utils_ip6_dns_to_variant(dns: *mut *mut c_char) -> *mut glib::GVariant;
    pub fn nm_utils_ip6_routes_from_variant(value: *mut glib::GVariant) -> *mut glib::GPtrArray;
    pub fn nm_utils_ip6_routes_to_variant(routes: *mut glib::GPtrArray) -> *mut glib::GVariant;
    pub fn nm_utils_ip_addresses_from_variant(value: *mut glib::GVariant, family: c_int) -> *mut glib::GPtrArray;
    pub fn nm_utils_ip_addresses_to_variant(addresses: *mut glib::GPtrArray) -> *mut glib::GVariant;
    pub fn nm_utils_ip_routes_from_variant(value: *mut glib::GVariant, family: c_int) -> *mut glib::GPtrArray;
    pub fn nm_utils_ip_routes_to_variant(routes: *mut glib::GPtrArray) -> *mut glib::GVariant;
    pub fn nm_utils_ipaddr_valid(family: c_int, ip: *const c_char) -> gboolean;
    pub fn nm_utils_is_empty_ssid(ssid: *mut u8, len: size_t) -> gboolean;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_utils_is_json_object(str: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    pub fn nm_utils_is_uuid(str: *const c_char) -> gboolean;
    pub fn nm_utils_is_valid_iface_name(name: *const c_char, error: *mut *mut glib::GError) -> gboolean;
    #[cfg(any(feature = "v1_8", feature = "dox"))]
    pub fn nm_utils_parse_variant_attributes(string: *const c_char, attr_separator: c_char, key_value_separator: c_char, ignore_unknown: gboolean, spec: *const *const NMVariantAttributeSpec, error: *mut *mut glib::GError) -> *mut glib::GHashTable;
    pub fn nm_utils_same_ssid(ssid1: *mut u8, len1: size_t, ssid2: *mut u8, len2: size_t, ignore_trailing_null: gboolean) -> gboolean;
    pub fn nm_utils_security_valid(type_: NMUtilsSecurityType, wifi_caps: NMDeviceWifiCapabilities, have_ap: gboolean, adhoc: gboolean, ap_flags: NM80211ApFlags, ap_wpa: NM80211ApSecurityFlags, ap_rsn: NM80211ApSecurityFlags) -> gboolean;
    pub fn nm_utils_ssid_to_utf8(ssid: *mut u8, len: size_t) -> *mut c_char;
    pub fn nm_utils_uuid_generate() -> *mut c_char;
    #[cfg(any(feature = "v1_6", feature = "dox"))]
    pub fn nm_utils_version() -> c_uint;
    pub fn nm_utils_wep_key_valid(key: *const c_char, wep_type: NMWepKeyType) -> gboolean;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_utils_wifi_2ghz_freqs() -> *const c_uint;
    #[cfg(any(feature = "v1_2", feature = "dox"))]
    pub fn nm_utils_wifi_5ghz_freqs() -> *const c_uint;
    pub fn nm_utils_wifi_channel_to_freq(channel: u32, band: *const c_char) -> u32;
    pub fn nm_utils_wifi_find_next_channel(channel: u32, direction: c_int, band: *mut c_char) -> u32;
    pub fn nm_utils_wifi_freq_to_channel(freq: u32) -> u32;
    pub fn nm_utils_wifi_is_channel_valid(channel: u32, band: *const c_char) -> gboolean;
    pub fn nm_utils_wifi_strength_bars(strength: u8) -> *const c_char;
    pub fn nm_utils_wpa_psk_valid(psk: *const c_char) -> gboolean;

}
